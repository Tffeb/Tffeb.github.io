<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>重学ES6（跟着《深入理解ES6》学习） &mdash; Tffeb’s Blog</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/share.js/dist/css/share.min.css"><link rel="canonical" href="http://localhost:4000/2019/12/21/restudy-ES6/"><link rel="alternate" type="application/atom+xml" title="Tffeb’s Blog" href="http://localhost:4000/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/favicon.ico"><meta property="og:title" content="重学ES6（跟着《深入理解ES6》学习）"><meta name="keywords" content="ES6"><meta name="og:keywords" content="ES6"><meta name="description" content=" 主流浏览器使用的是 es5、es6(es2015),ES6目前是新的标准, es7(2016), es8(2017), es9(2018), es10(2019)"><meta name="og:description" content=" 主流浏览器使用的是 es5、es6(es2015),ES6目前是新的标准, es7(2016), es8(2017), es9(2018), es10(2019)"><meta property="og:url" content="http://localhost:4000/2019/12/21/restudy-ES6/"><meta property="og:site_name" content="Tffeb’s Blog"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2019-12-21"> <script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/js/main.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="http://localhost:4000/" title="Tffeb’s Blog"><span class="octicon octicon-mark-github"></span> Tffeb’s Blog</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="http://localhost:4000/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="http://localhost:4000/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="http://localhost:4000/sparetime/" class=" site-header-nav-item" target="" title="业余">业余</a> <a href="http://localhost:4000/drop/" class=" site-header-nav-item" target="" title="点滴">点滴</a> <a href="http://localhost:4000/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="重学ES6（跟着《深入理解ES"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">重学ES6（跟着《深入理解ES6》学习）</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2019/12/21 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="http://localhost:4000/categories/#ES6" title="ES6">ES6</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 38476 字，约 110 分钟 </span></div></div></div><div class="column one-fourths mobile-hidden"><div class="collection-title"></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths content-artical" ><article class="article-content markdown-body"><blockquote><p>主流浏览器使用的是 es5、es6(es2015),ES6目前是新的标准, es7(2016), es8(2017), es9(2018), es10(2019)</p></blockquote><h3 id="一了解varletconst关键字的特性和用法">一、了解var、let、const关键字的特性和用法</h3><blockquote><p>var</p></blockquote><p>在javascript中，我们通常说的作用域是函数作用域，使用var声明的变量，无论是在代码的哪个地方声明的，都会提升到全局作用域的顶部，这种行为叫做<strong>变量提升</strong></p><p>也就是说，如果在函数内部声明的变量，都会被提升到该函数开头，而在全局声明的变量，就会提升到全局作用域的顶部。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example:</span>
<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//undefined</span>
  <span class="k">if</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">//undefined</span>
<span class="p">})()</span>
</code></pre></div></div><p>实际执行是，上面代码中的变量a会提升到函数顶部声明，即使if语句的条件是false,也一样不影响a变量提升</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">var</span> <span class="nx">a</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">//undefined</span>
  <span class="k">if</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">//undefined</span>
<span class="p">})()</span>
</code></pre></div></div><p>在函数嵌套函数的场景下，变量只会提升到最近的一个函数顶部，而不会提升到外部函数</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// b提升到函数a顶部，但不会提升到函数a外边.</span>
<span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// b is not undefined</span>
<span class="p">})()</span>
</code></pre></div></div><p>如果a没有声明，那么就会报错，<strong>没有声明和声明后没有赋值是不一样的</strong>，这一点要区分。<br /><br /></p><blockquote><p>let</p></blockquote><p>let和const都能够声明块级作用域，用法和var类似的，let的特点是不会变量提升，而是被锁在当前块中。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//example</span>
<span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">test</span><span class="p">();</span> <span class="c1">// a is not undefined</span>

<span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">test</span><span class="p">()</span> <span class="c1">// a is not defined</span>
</code></pre></div></div><p><br /><br /></p><blockquote><p>const</p></blockquote><p>声明常量，一旦声明，不可更改，而且常量必须初始化赋值。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">type</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ACTION</span><span class="dl">"</span>
<span class="nx">type</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="c1">// type is read-only</span>
<span class="kd">const</span> <span class="nx">type</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">ACTION</span><span class="dl">"</span>
<span class="kd">let</span> <span class="nx">type</span> <span class="o">=</span> <span class="mi">1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="c1">// duplicate declaration type</span>
</code></pre></div></div><p>const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object,那么可以修改对象内部的属性值包括新增删除键值对也是可以的。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">type</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span><span class="mi">1</span>
<span class="p">}</span>
<span class="nx">type</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">//没有直接修改type的值</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="c1">// {a:2}</span>

<span class="nx">type</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">//拓展Object也没问题</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="c1">//{a:2,b:3}</span>

<span class="k">delete</span> <span class="nx">type</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">3</span> <span class="c1">//删除整个键值对也可</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">type</span><span class="p">)</span> <span class="c1">// {a:2}</span>

<span class="c1">//如果重新定义数据结构，常量的内存地址值发生改变，这个是不可行的</span>
<span class="nx">type</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">//assignment to constant variable.</span>
<span class="nx">type</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">//assignment to constant variable.</span>
</code></pre></div></div><p><br /><br /></p><blockquote><p>const和let的异同点</p></blockquote><p><strong>相同点:</strong> const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升(TDZ),不能重复声明。</p><p><strong>不同点：</strong>const不能再赋值，let声明的变量可以重复赋值</p><p><code class="language-plaintext highlighter-rouge">临时(暂时性)死区(TDZ)</code> 临时死区的意思是在当前作用域的块内，在声明变量前的区域叫做临时死区。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//这块区域是TDZ</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span>
</code></pre></div></div><p><br /><br /></p><blockquote><p>块级作用域的使用场景</p></blockquote><p>在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">//5, 5, 5, 5, 5</span>
      <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">//5 i跳出循环体污染外部函数</span>
    
    <span class="c1">//将var改成let之后</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span> <span class="c1">// 0,1,2,3,4</span>
      <span class="p">},</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span><span class="c1">//i is not defined i无法污染外部函数</span>
</code></pre></div></div><p><br /><br /></p><blockquote><p>在全局作用域声明</p></blockquote><p>如果在全局作用域使用let或者const声明，当声明的变量本身就是全局属性，比如closed,只会覆盖该全局变量，而不会替换它，</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nb">window</span><span class="p">.</span><span class="nx">closed</span> <span class="o">=</span> <span class="kc">false</span>
  <span class="kd">let</span> <span class="nx">closed</span> <span class="o">=</span> <span class="kc">true</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">closed</span><span class="p">)</span> <span class="c1">// true</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">closed</span> <span class="c1">// false</span>
</code></pre></div></div><p><br /><br /></p><blockquote><p>最佳实践</p></blockquote><p>在实际开发中，我们选择使用var,let还是const,取决于我们的变量是不是需要更新，通常我们希望变量保证不被恶意修改，而使用大量的const,在react中，props传递的对象是不可更改的，所以使用const声明，声明一个对象的时候，也推荐使用const,当你需要修改声明的变量值时，使用let, var能用的场景都可以使用let替代。</p><p><br /><br /></p><h3 id="二了解字符串">二、了解字符串</h3><p>字符串(String)是js六大原始数据类型之一，其他几个分别是Boolean、Null、Undefined、Number、Symbol（es6新增）。</p><blockquote><p>ES6字符串新增的方法</p></blockquote><table><thead><tr><th style="text-align: center">新增</th><th>含义</th></tr></thead><tbody><tr><td style="text-align: center">UTF-16码位</td><td>ES6强制使用UTF-16字符串编码</td></tr><tr><td style="text-align: center">codePointAt()</td><td>该方法支持UTF-16，接受编码单元的位置而非字符串位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值。</td></tr><tr><td style="text-align: center">String.fromCodePoint()</td><td>作用与codePointAt相反，检索字符串中某个字符的码位，也可以根据指定的码位生成一个字符。</td></tr><tr><td style="text-align: center">normalize()</td><td>提供Unicode的标准形式，接受一个可选的字符串参数，指明应用某种Unicode标准形式。</td></tr></tbody></table><blockquote><p>字符串中的子串识别</p></blockquote><p><strong>ES6之前</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">abcdefg</span><span class="dl">"</span>
<span class="k">if</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">indexOf</span><span class="p">(</span><span class="dl">'</span><span class="s1">cd</span><span class="dl">'</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
<span class="c1">// 输出2，因为t字符串中包含cde字符串</span>
</code></pre></div></div><p><strong>ES6新增</strong></p><table><thead><tr><th style="text-align: center">新增</th><th>含义</th></tr></thead><tbody><tr><td style="text-align: center">includes(str, index)</td><td>如果在字符串中检测到指定文本，返回true，否则false。</td></tr><tr><td style="text-align: center">startsWith(str, index)</td><td>如果在字符串起始部分检测到指定文本，返回true，否则返回false。</td></tr><tr><td style="text-align: center">endsWith(str, index)</td><td>如果在字符串的结束部分检测到指定文本，返回true，否则返回false。</td></tr></tbody></table><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example  includes(str, index)</span>
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abcdefg</span><span class="dl">'</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">cde</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 2</span>


<span class="c1">// example  startsWith(str, index)</span>
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abcdefg</span><span class="dl">'</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">ab</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//2</span>


<span class="c1">// example  endsWith(str, index)</span>
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abcdefg</span><span class="dl">'</span>
    <span class="k">if</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="dl">'</span><span class="s1">fg</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//2</span>
</code></pre></div></div><p><strong>如果你只是需要匹配字符串中是否包含某个字符串，那么推荐使用新增的方法，如果需要找到匹配字符串的位置，使用indexOf()</strong></p><p><strong>repeat(number)方法</strong> 该方法接收一个Number类型的数据，返回一个重复N次的新字符串。即使这个字符串是空字符，也你能返回N个空字符的新字符串。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ba</span><span class="dl">'</span><span class="p">.</span><span class="nx">repeat</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>  <span class="c1">// babababa</span>
</code></pre></div></div><p><strong>模板字面量</strong></p><p>以前是单、双引号表示字符串</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">123</span><span class="dl">'</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">321</span><span class="dl">"</span>
</code></pre></div></div><p>在ES6，可以使用模板字面量反撇号``,在实际开发中，这是经常都要用到的方法。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="s2">`123`</span> 
</code></pre></div></div><p>在字符串中使用反撇号，只需要加上转义符即可。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">d</span> <span class="o">=</span> <span class="s2">`12\`3`</span>
</code></pre></div></div><p><strong>在多行字符串的使用价值</strong></p><p>模板字面量为解决多行字符串的一系列问题提供了一个非常好的机制。 如果不使用模板字面量，实现多行字符串，你可能会使用换行符。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">123</span><span class="se">\n</span><span class="s1">456</span><span class="dl">'</span>
</code></pre></div></div><p>使用模板字面量，就可以非常简单的实现需求。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">`123
  456
`</span>
</code></pre></div></div><p><strong>在模板字面量插入变量的方法</strong></p><p>我们不再需要使用 + 来向字符串插入变量，而是使用${params}直接插入你需要添加到字符串的位置。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="s2">`123</span><span class="p">${</span><span class="nx">t</span><span class="p">}</span><span class="s2">456`</span>
</code></pre></div></div><p>这种方式也叫作字符串占位符，占位符支持互相嵌套模板字面量。</p><p><strong>模板字面量的终极用法</strong></p><p>tag是一个方法，方法名称可以任意命名，这种写法被称作标签模板。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">tag</span><span class="p">(</span><span class="nx">literals</span><span class="p">,...</span><span class="nx">substitutions</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// literals是数组，第一个位置是"",第二个位置是站位符之间的字符串，本例中是sss</span>
  <span class="c1">// substitutions是字符串中模板字面量，可能多个</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">literals</span><span class="p">)</span> <span class="c1">// ["", " sss", "", raw: Array(3)] </span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">substitutions</span><span class="p">)</span> <span class="c1">// [4,2]</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">4</span>
<span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">tag</span><span class="s2">`</span><span class="p">${</span><span class="nx">a</span><span class="p">}</span><span class="s2"> sss</span><span class="p">${</span><span class="mi">2</span><span class="p">}</span><span class="s2">`</span>
</code></pre></div></div><p><strong>总结</strong></p><p>本章降到ES6中新增的Unicode方法,如果不需要做国际化处理，基本上用不到，关注新增的字符串匹配的3个方法，以及模板字面量的使用，这两点很常用。</p><p><br /><br /></p><h3 id="三函数">三、函数</h3><p>在ES5中，我们给函数传参数，然后在函数体内设置默认值，如下面这种方式。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span><span class="nx">callback</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">num</span> <span class="o">=</span> <span class="nx">num</span> <span class="o">||</span> <span class="mi">6</span><span class="p">;</span>
  <span class="nx">callback</span> <span class="o">=</span> <span class="nx">callback</span> <span class="o">||</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ES5:</span><span class="dl">'</span><span class="p">,</span><span class="nx">data</span><span class="p">)}</span>
  <span class="nx">callback</span><span class="p">(</span><span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">()</span> 
</code></pre></div></div><p>在ES6中，我们使用新的默认值写法</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span><span class="nx">callback</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">ES6</span><span class="dl">'</span><span class="p">,</span><span class="nx">data</span><span class="p">)</span>
  <span class="p">})</span> <span class="p">{</span>
    <span class="nx">callback</span><span class="p">(</span><span class="nx">num</span> <span class="o">*</span> <span class="nx">num</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">a</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">){</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="o">*</span><span class="mi">10</span><span class="p">)})</span>
</code></pre></div></div><p>***** <code class="language-plaintext highlighter-rouge">使用es6的默认值写法可以让函数体内的代码更加简洁优雅</code></p><p><br /></p><p><strong>默认值对arguments对象的影响</strong></p><p>我们先要了解arguments对象是啥？准确来说它是一个类数组对象，它在函数内部，它将当前函数的所有参数都组成了一个类数组对象。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>  <span class="c1">// {"0": 6, "1": 10}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="c1">// 2</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div><p>上面的输出结果看起来很正常，那么，如果加上默认值会怎样呢？</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">()</span> <span class="c1">// {} 默认值不能被arguments识别。</span>
<span class="nx">a</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// {"0": 6, "1": 10}</span>
</code></pre></div></div><p>下面我们看一下修改参数默认值对arguments的影响。</p><p>1、在ES5的非严格模式下，一开始输入的参数是1，那么可以获取到arguments[0],修改num = 2之后，arguments[0]也能更新到2</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span> <span class="o">===</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">// true</span>
  <span class="nx">num</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1">// 修改参数默认值</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span> <span class="o">===</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1">// true</span>
<span class="p">}</span>
<span class="nx">a</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div></div><p>2、在es5严格模式下，arguments就不能在函数内修改默认值后跟随着更新了</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span> <span class="c1">//严格模式   </span>
    <span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span> <span class="o">===</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// true</span>
      <span class="nx">num</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span> <span class="o">===</span> <span class="nx">arguments</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span> <span class="c1">// false</span>
    <span class="p">}</span>
    <span class="nx">a</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div></div><p><em>**</em> <code class="language-plaintext highlighter-rouge">在ES6环境下，默认值对arguments的影响和ES5严格模式是同样的标准。</code></p><p><strong>默认参数表达式</strong></p><p>参数不仅可以设置默认值为字符串，数字，数字或者对象，还可以是一个函数</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">10</span>
  <span class="p">}</span>
  <span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">num</span> <span class="o">=</span> <span class="nx">add</span><span class="p">())</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">num</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="nx">a</span><span class="p">()</span> <span class="c1">// 10</span>
</code></pre></div></div><p><strong>默认参数的临时死区</strong></p><p>第一章我们提到let、const什么是变量的TDZ,默认参数既然是参数，那么也同样有临时死区，函数的作用域是独立的，a函数不能共享b函数的作用域参数。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//这是个默认参数临时死区的例子，当初始化a时，b还没有声明，所以第一个参数对b来说就是临时死区。</span>
    <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">b</span><span class="p">){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">add</span><span class="p">(</span><span class="kc">undefined</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">// b is not define</span>
</code></pre></div></div><p><strong>无命名参数</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">object</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">object</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">object</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">a</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span>
  <span class="na">b</span><span class="p">:</span><span class="mi">2</span>
<span class="p">}</span>
<span class="nx">add</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="c1">// 3</span>
</code></pre></div></div><p><strong>不定参数的使用</strong></p><p>使用…（展开运算符）的参数就是不定参数，它表示一个数组</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">function</span> <span class="nx">add</span><span class="p">(...</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span> 
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span>  <span class="c1">// 3</span>
</code></pre></div></div><p><strong>不定参数的使用限制</strong></p><p>必须放在所有参数的末尾，不能用于对象字面量setter中。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 错误的写法1</span>
  <span class="kd">function</span> <span class="nx">add</span><span class="p">(...</span><span class="nx">arr</span><span class="p">,</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">)</span> 
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span><span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span><span class="nx">c</span> <span class="o">=</span> <span class="mi">3</span>
  <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">)</span>

  <span class="c1">// 错误的写法2</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kd">set</span> <span class="nx">add</span><span class="p">(...</span><span class="nx">arr</span><span class="p">)</span> <span class="p">{</span>

    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div><p>***** <code class="language-plaintext highlighter-rouge">ES6中的构造函数Function新增了支持默认参数和不定参数</code></p><p><strong>展开操作符</strong></p><p>展开运算符的作用是解构数组，然后将每个数组元素作为函数参数，有了展开运算符，我们操作数组的时候，就可以不再使用apply来指定上下文环境了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// es5的写法</span>
<span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">50</span><span class="p">,</span><span class="mi">40</span><span class="p">,</span><span class="mi">30</span><span class="p">]</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span><span class="nx">arr</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// 50</span>

<span class="c1">// es6的写法</span>
<span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">40</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(...</span><span class="nx">arr</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>  <span class="c1">// 40</span>
</code></pre></div></div><p><strong>块级函数</strong></p><p><code class="language-plaintext highlighter-rouge">严格模式下</code>在es6中，你可以在块级作用域内声明函数，该函数的作用域只限于当前块，不能在块的外部访问。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>
 <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
   <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>

   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">非严格模式</code>即使在ES6中，非严格模式下的块级函数，他的作用域也会被提升到父级函数的顶部。所以大家写代码尽量使用严格模式，避免这些奇葩情况。</p><p><strong>箭头函数</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">]</span>
  <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">sum</span><span class="p">,</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">item</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// 15</span>
</code></pre></div></div><p><strong>箭头函数和普通函数的区别</strong></p><p>1、箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。</p><p>2、箭头函数没有super</p><p>3、箭头函数没有arguments</p><p>4、箭头函数没有new.target绑定。</p><p>5、不能使用new</p><p>6、没有原型</p><p>7、不支持重复的命名参数。</p><p><strong>箭头函数的简单理解</strong></p><p>1、箭头函数的左边表示输入的参数，右边表示输出的结果。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span> <span class="c1">// 2</span>
</code></pre></div></div><p>2、箭头函数中，最重要的this报错将不再成为你每天都担心的bug。</p><p>3、箭头函数还可以输出对象。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">action</span> <span class="o">=</span> <span class="p">(</span><span class="nx">type</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">({</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">TYPE</span><span class="dl">"</span><span class="p">,</span>
      <span class="nx">a</span>
    <span class="p">})</span>
</code></pre></div></div><p>4、支持立即执行函数表达式写法</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">test</span> <span class="o">=</span> <span class="p">((</span><span class="nx">id</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">getId</span><span class="p">()</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">})(</span><span class="mi">18</span><span class="p">)</span>
    <span class="nx">test</span><span class="p">.</span><span class="nx">getId</span><span class="p">()</span> <span class="c1">// 18</span>
</code></pre></div></div><p>5、箭头函数给数组排序</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">20</span><span class="p">]</span>
    <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">sort</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span> <span class="o">-</span> <span class="nx">b</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [10,20,30,40,50]</span>
</code></pre></div></div><p><strong>尾调用优化</strong></p><p>尾调用是指在函数return的时候用一个新的函数,由于尾调用的实现需要存储到内存中,在一个循环体中，如果存在函数的尾调用，你的内存可能爆满或溢出。</p><blockquote><p>ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求：</p></blockquote><p>1、函数不是闭包</p><p>2、尾调用是函数最后一条语句</p><p>3、尾调用结果作为函数返回</p><p><strong>一个满足以上要求的函数如下所示：</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>   
    <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">b</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>下面的都是不满足的写法：</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//没有return不优化</span>
    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">b</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="c1">//不是直接返回函数不优化</span>
    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="nx">b</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="c1">//尾调用是函数不是最后一条语句不优化</span>
    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">b</span><span class="p">();</span>
      <span class="k">return</span> <span class="nx">s</span>
    <span class="p">}</span>
    
    <span class="c1">//闭包不优化</span>
    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="kd">function</span> <span class="nx">b</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">num</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nx">b</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>尾调用实际用途——递归函数优化</strong></p><p>在ES5时代，我们不推荐使用递归，因为递归会影响性能。</p><p>但是有了尾调用优化之后，递归函数的性能有了提升。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//新型尾优化写法</span>
    <span class="dl">"</span><span class="s2">use strict</span><span class="dl">"</span><span class="p">;</span>  
    <span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="nx">p</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">*</span> <span class="nx">p</span>
      <span class="p">}</span>
      <span class="kd">let</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">n</span> <span class="o">*</span> <span class="nx">p</span>
      <span class="k">return</span> <span class="nx">a</span><span class="p">(</span><span class="nx">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">s</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//求 1 x 2 x 3的阶乘</span>
    <span class="kd">let</span> <span class="nx">sum</span> <span class="o">=</span> <span class="nx">a</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span> <span class="c1">// 6</span>
</code></pre></div></div><p><br /> <br /></p><h3 id="四对象">四、对象</h3><p>在ES6中，对象分为下面几种叫法</p><ul><li><p>普通对象</p></li><li><p>特异对象</p></li><li><p>标准对象</p></li><li><p>内建对象</p></li></ul><p><strong>对象字面量语法拓展</strong></p><p>随便打开一个js文件，对象都无处不在，看一个简单的对象。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">{</span>
      <span class="nl">a</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>es6针对对象的语法扩展了一下功能</strong></p><p>1、属性初始值简写</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// es5</span>
<span class="kd">function</span> <span class="nx">a</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span><span class="p">{</span>
    <span class="na">id</span><span class="p">:</span><span class="nx">id</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// es6</span>
<span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">id</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="nx">id</span>
<span class="p">})</span>
</code></pre></div></div><p>2、对象方法简写</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// ES5</span>
    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">printId</span><span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="c1">// ES6</span>
    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="nx">printId</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><p>3、属性名可计算</p><p>属性名可以传入变量或者常量，而不只是一个固定的字符串。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">id</span> <span class="o">=</span> <span class="mi">5</span>
  <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="s2">`my-</span><span class="p">${</span><span class="nx">id</span><span class="p">}</span><span class="s2">`</span><span class="p">]:</span><span class="nx">id</span>
  <span class="p">}</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="dl">'</span><span class="s1">my-5</span><span class="dl">'</span><span class="p">])</span> <span class="c1">// 5</span>
</code></pre></div></div><p><strong>es6对象新增方法</strong></p><p>在Object原始对象上新增方法，原则上来说不可取，但是为了解决全世界各地提交的issue,在es6中的全局Object对象上新增了一些方法。</p><p><code class="language-plaintext highlighter-rouge">Object.is()</code></p><p>用来解决Javascript中特殊类型 == 或者 === 异常的情况</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// example</span>
    <span class="c1">//实际出现了异常(错误输出)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span><span class="p">)</span> <span class="c1">// false</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">5</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//true</span>
    
    <span class="c1">//我们期望的目标输出(正确输出)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kc">NaN</span> <span class="o">===</span> <span class="kc">NaN</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span> <span class="o">===</span> <span class="o">-</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// false</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="mi">5</span> <span class="o">==</span> <span class="dl">"</span><span class="s2">5</span><span class="dl">"</span><span class="p">)</span> <span class="c1">//false</span>
</code></pre></div></div><p>为了解决上面问题，<strong>新增了Object.is()来处理2个值的比较。</strong></p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="kc">NaN</span><span class="p">,</span> <span class="kc">NaN</span><span class="p">))</span> <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="o">+</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">0</span><span class="p">))</span> <span class="c1">// false</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="dl">"</span><span class="s2">5</span><span class="dl">"</span><span class="p">))</span> <span class="c1">//false</span>
</code></pre></div></div><p><strong>Object.assign()</strong></p><p>也许你已经见过或者使用过这个方法了，那这个新增的方法解决了什么问题呢？</p><p>答：混合（Mixin）。</p><p>mixin是一个方法，实现了拷贝一个对象给另外一个对象，返回一个新的对象。</p><p>下面是一个mixin方法的实现，这个方法实现的是<code class="language-plaintext highlighter-rouge">浅拷贝</code>。将b对象的属性拷贝到了a对象，合并成一个新的对象。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// mixin不只有这一种实现方法</span>
<span class="kd">function</span> <span class="nx">mixin</span><span class="p">(</span><span class="nx">receiver</span><span class="p">,</span><span class="nx">supplier</span><span class="p">)</span> <span class="p">{</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">supplier</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">key</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">receiver</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">supplier</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
  <span class="p">})</span>
  <span class="k">return</span> <span class="nx">receiver</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">cnm</span><span class="dl">'</span><span class="p">};</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">c</span><span class="p">:{</span>
    <span class="na">d</span><span class="p">:</span><span class="mi">5</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mixin</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">))</span> <span class="c1">// {"name":"cnm","c":{"d":5}}</span>
</code></pre></div></div><p>写这样一个mixin方法是不是很烦，而且每个项目都得引入这个方法，现在，ES6给我们提供了一个现成的方法Object.assign()来做mixin的事情。</p><p>假设要实现上面的mixin方法，你只需要给Object.assign()传入参数即可。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">))</span><span class="c1">// {"name":"cnm","c":{"d":5}}</span>
</code></pre></div></div><p><strong>使用Object.assign()继承</strong></p><p>Object.assign 方法只复制源对象中可枚举的属性和对象自身的属性。</p><p><strong>看一个实现Component的例子。</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//声明一个对象Component</span>
    <span class="kd">let</span> <span class="nx">Component</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1">//给对象添加原型方法</span>
    <span class="nx">Component</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nx">componentWillMount</span><span class="p">()</span> <span class="p">{},</span>
      <span class="nx">componentDidMount</span><span class="p">()</span> <span class="p">{},</span>
      <span class="nx">render</span><span class="p">()</span> <span class="p">{</span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">render</span><span class="dl">'</span><span class="p">)}</span>
    <span class="p">}</span>
    <span class="c1">//定义一个新的对象</span>
    <span class="kd">let</span> <span class="nx">MyComponent</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1">//拷贝Component的方法和属性。</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">MyComponent</span><span class="p">,</span> <span class="nx">Component</span><span class="p">.</span><span class="nx">prototype</span><span class="p">)</span>
    
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">MyComponent</span><span class="p">.</span><span class="nx">render</span><span class="p">())</span> <span class="c1">// render</span>
</code></pre></div></div><p><strong>在react的reducer中，每次传入新的参数返回新的state，你都可能用到Object.assign()方法。</strong></p><p><code class="language-plaintext highlighter-rouge">重复的对象字面量属性</code> ES5的严格模式下，如果你的对象中出现了key相同的情况，那么就会抛出错误。而在ES6的严格模式下，不会报错，后面的key会覆盖掉前面相同的key。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">id</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span> <span class="c1">// 2</span>
</code></pre></div></div><p><strong>自有属性枚举顺序</strong></p><p>这个概念看起来比较模糊，如果你看了下面的例子，你可能就会明白在说什么了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">const</span> <span class="nx">state</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">id</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="mi">5</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
      <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">eryue</span><span class="dl">"</span><span class="p">,</span>
      <span class="mi">3</span><span class="p">:</span> <span class="mi">3</span>
    <span class="p">}</span>
    
    <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyNames</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> 
    <span class="c1">//["3","5","id","name"] 枚举key</span>

    <span class="nb">Object</span><span class="p">.</span><span class="nx">assign</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span>
    <span class="c1">//{"3":3,"5":5,"id":1,"name":"eryue"} </span>
</code></pre></div></div><p>上面的例子的输出结果都有个规律，就是数字提前，按顺序排序，接着是字母排序。而这种行为也是ES6新增的标准。你还可以自己测试一下其他方法是不是也支持枚举自动排序。比如Object.keys(), for in 等。</p><p><strong>增强对象原型</strong></p><p>如果你想定义一个对象，你会想到很多方法</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{}</span>
  <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
  <span class="kd">function</span> <span class="nx">C</span><span class="p">()</span> <span class="p">{}</span>
  <span class="kd">class</span> <span class="nx">D</span> <span class="p">{}</span>
</code></pre></div></div><p>那么，ES6是如何在这么强大的对象上面继续增强功能呢？</p><p>1、允许改变对象原型</p><p>改变对象原型，是指在对象实例化之后，可以改变对象原型，我们使用Object.setPrototypeOf() 来改变实例化后的对象原型。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">eryue</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">())</span> <span class="c1">// true</span>

  <span class="c1">// 使用setPrototypeOf改变b的原型</span>
  <span class="kd">let</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">name</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">sb</span><span class="dl">'</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="nb">Object</span><span class="p">.</span><span class="nx">setPrototypeOf</span><span class="p">(</span><span class="nx">b</span><span class="p">,</span><span class="nx">c</span><span class="p">)</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">name</span><span class="p">())</span> <span class="c1">// sb</span>
</code></pre></div></div><p><strong>方法的定义</strong></p><p>ES6明确了方法的定义</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1">// 方法</span>
    <span class="nx">name</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="dl">'</span><span class="s1">eryue</span><span class="dl">'</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
   <span class="c1">// 函数</span>
  <span class="kd">function</span> <span class="nx">name</span> <span class="p">()</span> <span class="p">{}</span>
</code></pre></div></div><p><strong>总结</strong></p><p>本章讲解了对象字面量语法拓展，ES6新增方法，允许重复的对象字面量属性，自有枚举属性排序，增强对象原型，明确了方法的定义。</p><p><br /><br /></p><h3 id="五解构语法">五、解构语法</h3><p><strong>解构的分类</strong></p><p>1、对象解构</p><p>2、数组解构</p><p>3、混合解构</p><p>4、解构参数</p><h4 id="对象解构">对象解构</h4><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">b</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="p">}</span>
    <span class="c1">// 对象解构</span>
    <span class="kd">const</span> <span class="p">{</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//1  [1, 2]</span>
</code></pre></div></div><p><em>在函数中使用解构赋值</em></p><p>解构是将对象或者数组的元素一个个提取出来，而赋值是给元素赋值，解构赋值的作用就是给对象或者数组的元素赋值。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">props</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">b</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">test</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">test</span><span class="p">({</span><span class="nx">a</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="nx">b</span><span class="o">=</span><span class="mi">3</span><span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">)</span> <span class="c1">// {a: 1, b: 2}</span>
</code></pre></div></div><p>在调用test()函数的时候，我们给参数设置了默认值3，如果不重新赋值，则打印出3,3，但是进行解构赋值后，将props对象的参数解构赋值给a和b，所以打印结果是{a: 1, b: 2}</p><p>下面这个例子定义了a = 3,b = 3两个变量，现在我们想修改这2个变量的值，采用解构赋值的方式可以这样做：定义一个props对象，该对象包含2个属性a和b，然后进行解构赋值，这时就能更新变量a和b的value。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">props</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">b</span><span class="p">:</span> <span class="mi">2</span>
    <span class="p">},</span>
    <span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="c1">//解构赋值</span>
    <span class="p">({</span> <span class="nx">a</span><span class="p">,</span> <span class="nx">b</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">props</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// 1, 2</span>
</code></pre></div></div><p><strong>在react的父子组件传递参数过程中，也使用到了解构赋值。</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">Parent</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
      <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="p">{</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">}</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span>
        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">a</span><span class="p">}</span><span class="o">-</span><span class="p">{</span><span class="nx">b</span><span class="p">}</span><span class="o">&lt;</span><span class="sr">/h1</span><span class="err">&gt;
</span>      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="nx">ReactDOM</span><span class="p">.</span><span class="nx">render</span><span class="p">(</span>
      <span class="o">&lt;</span><span class="nx">Parent</span> <span class="nx">a</span><span class="o">=</span><span class="dl">"</span><span class="s2">1</span><span class="dl">"</span> <span class="nx">b</span><span class="o">=</span><span class="dl">"</span><span class="s2">2</span><span class="dl">"</span> <span class="o">/&gt;</span><span class="p">,</span>
      <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">root</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">);</span>
    <span class="c1">//在浏览器渲染 1-2，默认值是 3-3，但是因为传递了新的props进来，执行了解构赋值之后a和b更新了。</span>
</code></pre></div></div><p><strong>嵌套对象解构</strong></p><p>当对象层次较深时，你也可以解构出来。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
          <span class="na">c</span><span class="p">:</span> <span class="mi">5</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="p">{</span><span class="nx">b</span><span class="p">}}</span> <span class="o">=</span> <span class="nx">obj</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// 5</span>
</code></pre></div></div><p><br /></p><h4 id="数组解构">数组解构</h4><p>数组解构比对象解构简单，因为数组只有数组字面量，不需要像对象一个使用key属性。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    
    <span class="c1">//解构前2个元素</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="c1">//1 2</span>
    
    <span class="c1">//解构中间的元素</span>
    <span class="kd">const</span> <span class="p">[,</span> <span class="nx">b</span><span class="p">,]</span> <span class="o">=</span> <span class="nx">arr</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 2</span>
</code></pre></div></div><p><em>解构赋值</em></p><p>如果你没有看明白上面说到的对象解构赋值的含义，那么看完下面的数组解构赋值，或许你会有比较清晰的理解。</p><p>这个例子中，正常情况下打印a的值是haha，但是将数组arr的第一个元素解构赋值给a，a的值就变成了1。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//初始化一个变量a</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">haha</span><span class="dl">"</span><span class="p">;</span>
    <span class="c1">//定义一个数组</span>
    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="c1">//解构赋值a，将arr数组的第一个元素解构赋值给a，</span>
    <span class="p">[</span><span class="nx">a</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>
</code></pre></div></div><p>使用解构赋值，还可以调换2个变量的值。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nx">b</span><span class="p">,</span> <span class="nx">a</span><span class="p">];</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 2 1 </span>
</code></pre></div></div><p><strong>嵌套数组解构</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">4</span><span class="p">];</span>
    <span class="kd">let</span> <span class="p">[</span><span class="nx">a</span><span class="p">,</span> <span class="p">[,</span><span class="nx">b</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">// 1 3</span>
    
    <span class="c1">//实际解构过程，左边的变量和右边的数组元素一一对应下标。</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="nx">_arr$</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="nx">_arr$</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</code></pre></div></div><p><strong>不定元素解构</strong></p><p>三个点的解构赋值必须放在所有解构元素的最末尾，否则报错。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">];</span>
    <span class="kd">let</span> <span class="p">[...</span><span class="nx">a</span><span class="p">]</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">//[1,2,3,4] 这种做法就是克隆arr数组。</span>
</code></pre></div></div><p><br /></p><h4 id="混合解构">混合解构</h4><p>混合解构指的是对象和数组混合起来，执行解构操作，没什么难度。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">id</span><span class="p">:</span> <span class="mi">1</span>
      <span class="p">},</span>
      <span class="na">b</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="p">}</span>
    
    <span class="kd">const</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="p">{</span><span class="nx">id</span><span class="p">},</span>
      <span class="na">b</span><span class="p">:[...</span><span class="nx">arr</span><span class="p">]</span>
    <span class="p">}</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">,</span> <span class="nx">arr</span><span class="p">)</span> <span class="c1">//id = 1, arr = [2, 3]</span>
</code></pre></div></div><p><br /></p><h4 id="解构参数">解构参数</h4><p>当给函数传递参数时，我们可以对每个参数进行解构，我给option的参数设置了默认值，这样可以防止没有给option传参导致的报错情况。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">Ajax</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">options</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="p">{</span><span class="nx">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">jsonp</span> <span class="o">=</span> <span class="kc">true</span><span class="p">}</span> <span class="o">=</span> <span class="nx">options</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">url</span><span class="p">,</span> <span class="nx">timeout</span><span class="p">,</span> <span class="nx">jsonp</span><span class="p">)</span>
    <span class="p">};</span>
    <span class="nx">Ajax</span><span class="p">(</span><span class="dl">'</span><span class="s1">baidu.com</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
      <span class="na">timeout</span><span class="p">:</span> <span class="mi">1000</span><span class="p">,</span>
      <span class="na">jsonp</span><span class="p">:</span> <span class="kc">false</span>
    <span class="p">})</span> <span class="c1">// "baidu.com" 1000 false</span>
</code></pre></div></div><p><strong>总结</strong></p><p>本章讲解了对象解构赋值和数组解构赋值，以及对象和数组混合情况下的解构赋值操作，最后一个知识点是解构函数的参数。</p><p><br /><br /></p><h3 id="六symbol和symbol属性">六、Symbol和Symbol属性</h3><p>在ES5的时代，对象的key只能是字符串String类型。有人就想搞事，把key改成其他数据类型，这不是瞎折腾吗？ES组织的大神们为了对付这类搞事的人，就指定了一个新的数据类型：Symbol。</p><p><strong>原始数据类型</strong></p><p>学习Symbol之前，让我们回忆一下你曾经用过的原始数据类型，只有5个，别搞错了。</p><p><code class="language-plaintext highlighter-rouge">null、undefined</code> 是不是面试的时候有人问过你这两者的区别？问这种问题的人很无聊，你要是和他当同事，真是受罪。</p><p><strong>Number 数字类型</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="k">typeof</span> <span class="nx">a</span> <span class="c1">// number</span>
</code></pre></div></div><p><strong>String 字符串</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span>
    <span class="k">typeof</span> <span class="nx">a</span> <span class="c1">// string</span>
</code></pre></div></div><p><strong>boolean 布尔型</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">b</span> <span class="o">=</span> <span class="kc">false</span>
</code></pre></div></div><p><strong>Symbol</strong></p><p>Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。Symbol 对象是一个 symbol primitive data type 的隐式对象包装器。</p><p><strong>Symbol的语法格式：</strong></p><p>Symbol([description]) //description是可选的</p><p><strong>创建一个Symbol：</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">name1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">sym1</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">name1</span><span class="p">)</span> <span class="c1">// Symbol() Symbol(sym1)</span>
</code></pre></div></div><p>Symbol不能使用new</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Symbol</span><span class="p">();</span> <span class="c1">//不可以这样做。</span>
    <span class="c1">//Symbol is not a constructor</span>
</code></pre></div></div><p><strong>使用Symbol：</strong></p><p>使用Number的时候，我们可以这样写：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// 10</span>
    <span class="c1">//简写</span>
    <span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">10</span>
</code></pre></div></div><p>同理，使用Symbol，我们可以这样：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">name1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">sym1</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// Symbol(sym1)</span>
</code></pre></div></div><p>在所有使用可计算属性名的地方，都能使用Symbol类型。比如在对象中的key。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="p">[</span><span class="nx">name</span><span class="p">]:</span> <span class="dl">"</span><span class="s2">haha</span><span class="dl">"</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">name</span><span class="p">])</span> <span class="c1">// haha</span>
</code></pre></div></div><p>你还可以使用Object.defineProperty()和Object.defineProperties()方法。这2个方法是对象的方法，但是作为Symbol类型key，也不影响使用。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 设置对象属性只读。</span>
    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">name</span><span class="p">,</span> <span class="p">{</span><span class="na">writable</span><span class="p">:</span> <span class="kc">false</span><span class="p">})</span>
</code></pre></div></div><p>这2个方法非常有用，在react源码中，使用了大量的只读属性的对象。以下是从react源码截取的一段代码，设置了props对象只读。但是react仍旧使用字符串作为key，并不用Symbol。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Object</span><span class="p">.</span><span class="nx">defineProperty</span><span class="p">(</span><span class="nx">props</span><span class="p">,</span> <span class="dl">'</span><span class="s1">key</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
        <span class="na">get</span><span class="p">:</span> <span class="nx">warnAboutAccessingKey</span><span class="p">,</span>
        <span class="na">configurable</span><span class="p">:</span> <span class="kc">true</span>
      <span class="p">});</span>
</code></pre></div></div><p><strong>Symbol全局共享</strong></p><p>Symbol有点特殊，在js文件中定义的Symbol，并不能在其他文件直接共享。</p><p>ES6提供了一个注册机制，当你注册Symbol之后，就能在全局共享注册表里面的Symbol。Symbol的注册表和对象表很像，都是key、value结构，只不过这个value是Symbol值。 （key, Symbol） 语法：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">()</span> <span class="c1">//只有一个参数</span>
</code></pre></div></div><p>还有一个方法是获取注册表的Symbol。</p><p>语法：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">()</span> <span class="c1">//只有一个参数，返回的是key</span>
</code></pre></div></div><p>从注册表获取全局共享的Symbol</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">name</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">name1</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">name1</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">let</span> <span class="nx">name2</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">.</span><span class="k">for</span><span class="p">(</span><span class="dl">'</span><span class="s1">name2</span><span class="dl">'</span><span class="p">);</span>
    
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span> <span class="c1">// name</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">name1</span><span class="p">))</span> <span class="c1">// name1</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">keyFor</span><span class="p">(</span><span class="nx">name2</span><span class="p">))</span> <span class="c1">// name2</span>
</code></pre></div></div><p>注意：如果要防止Symbol命名重复问题，可以加上前缀。如：hyy.name</p><p><strong>Symbol与类型强制转换</strong></p><p>JavaScript中的类型可以自动转换。比如Number转换成字符串。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// number</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> haha</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// '1haha'</span>
</code></pre></div></div><p>但是注意了，Symbol不支持这种转换。Symbol就是这么拽啊！</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">a</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span> <span class="o">+</span> <span class="dl">'</span><span class="s1"> haha</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// Cannot convert a Symbol value to a string</span>
</code></pre></div></div><p><strong>Symbol检索</strong></p><p>在对象中获取字符串的key时，可以使用Object.keys()或Object. getOwnPropertyNames()方法获取key,但是使用Symbol做key时，你就只能使用ES6新增的方法来获取了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
  <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">[</span><span class="nx">a</span><span class="p">]:</span><span class="dl">"</span><span class="s2">123</span><span class="dl">"</span><span class="p">,</span>
    <span class="p">[</span><span class="nx">b</span><span class="p">]:</span><span class="mi">45</span>  
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">symbolsKey</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertySymbols</span><span class="p">(</span><span class="nx">obj</span><span class="p">);</span>
    
  <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">symbolsKey</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">[</span><span class="nx">value</span><span class="p">])</span> 
  <span class="p">}</span>
</code></pre></div></div><p><strong>总结</strong></p><p>Symbol是JavaScript的原始数据类型，一个全新的数据类型，和对象、数字、字符串等完全不一样，它必须通过Symbol()创建。</p><p><br /><br /></p><h3 id="七set和map">七、Set和Map</h3><h4 id="set">Set</h4><blockquote><p>Set是有序列表，含有相互独立的非重复值。</p></blockquote><p><strong>创建一个Set集合</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">);</span>
    
    <span class="c1">//在浏览器控制台的输出结果</span>
    <span class="nb">Set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
        <span class="nl">size</span><span class="p">:(...)</span>
        <span class="nx">__proto__</span><span class="p">:</span><span class="nb">Set</span>
        <span class="p">[[</span><span class="nx">Entries</span><span class="p">]]:</span><span class="nb">Array</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="nx">length</span><span class="p">:</span><span class="mi">0</span>
</code></pre></div></div><p>看起来像个对象，那么现在我们在控制台打印一个对象，对比一下两者有什么不同。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span>
    
    <span class="c1">//在控制台输出对象</span>
    <span class="nb">Object</span> <span class="p">{}</span>
        <span class="nl">__proto__</span><span class="p">:</span> 
</code></pre></div></div><p>从输出结果看，Set和Object有明显的区别，反正他们就不是一个东西。</p><p><strong>接着，我们看一下Set的原型有哪些：</strong></p><table><thead><tr><th style="text-align: center">原型</th><th>含义</th></tr></thead><tbody><tr><td style="text-align: center">Set.prototype.size</td><td>返回Set对象的值的个数。</td></tr><tr><td style="text-align: center">Set.prototype.add(value)</td><td>在Set对象尾部添加一个元素。返回该Set对象。</td></tr><tr><td style="text-align: center">Set.prototype.entries()</td><td>返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。</td></tr><tr><td style="text-align: center">Set.prototype.forEach(callbackFn[, thisArg])</td><td>按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。</td></tr><tr><td style="text-align: center">Set.prototype.has(value)</td><td>返回一个布尔值，表示该值在Set中存在与否。</td></tr></tbody></table><p><strong>在例子中使用这几个方法测试一下：</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">);</span>
    <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nb">Symbol</span><span class="p">(</span><span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">));</span>
    
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">.</span><span class="nx">size</span><span class="p">);</span> <span class="c1">//2</span>
    
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">);</span> 
    <span class="nb">Set</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="dl">"</span><span class="s2">haha</span><span class="dl">"</span><span class="p">,</span> <span class="nb">Symbol</span><span class="p">(</span><span class="nx">haha</span><span class="p">)}</span>
        <span class="nl">size</span><span class="p">:(...)</span>
        <span class="nx">__proto__</span><span class="p">:</span><span class="nb">Set</span>
        <span class="p">[[</span><span class="nx">Entries</span><span class="p">]]:</span><span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="mi">0</span><span class="p">:</span><span class="dl">"</span><span class="s2">haha</span><span class="dl">"</span>
            <span class="mi">1</span><span class="p">:</span><span class="nb">Symbol</span><span class="p">(</span><span class="nx">haha</span><span class="p">)</span>
        <span class="nx">length</span><span class="p">:</span><span class="mi">2</span>
        
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// true</span>
</code></pre></div></div><p>到这里，你会发现Set像数组，又像一个对象，但又不完全是。</p><p><strong>迭代Set</strong></p><p>Set既然提供了entries和forEach方法，那么他就是可迭代的。</p><p>但如果你使用for in来迭代Set，你不能这样做：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">sets</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">);</span> <span class="c1">//undefined</span>
    <span class="p">}</span>
</code></pre></div></div><p>for in迭代的是对象的key，而在Set中的元素没有key</p><p><strong>使用for of来遍历</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">sets</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//"haha"</span>
    <span class="c1">//Symbol(haha)</span>
    
    <span class="c1">//如果你需要key，则使用下面这种方法</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">sets</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="p">}</span> 
    <span class="c1">//"haha" "haha"</span>
    <span class="c1">//Symbol(haha) Symbol(haha)</span>
</code></pre></div></div><p><strong>forEach操作Set：</strong></p><p>Set本身没有key，而forEach方法中的key被设置成了元素本身。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">sets</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">);</span>
    <span class="p">});</span>
    <span class="c1">//"haha" "haha"</span>
    <span class="c1">//Symbol(haha) Symbol(haha)</span>
    
    <span class="nx">sets</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Object</span><span class="p">.</span><span class="nx">is</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">));</span>
    <span class="p">});</span> 
    <span class="c1">//true true</span>
</code></pre></div></div><p><strong>Set和Array的转换</strong></p><p>Set和数组太像了，Set集合的特点是没有key，没有下标，只有size和原型以及一个可迭代的不重复元素的类数组。既然这样，我们就可以把一个Set集合转换成数组，也可以把数组转换成Set。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数组转换成Set</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">]</span>
    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">)</span> <span class="c1">// Set(3) {1, 2, "3"}</span>

    <span class="c1">//Set转换成数组</span>
    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">();</span>
    <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="kd">set</span><span class="p">))</span> <span class="c1">// (2) [1, "2"]</span>
</code></pre></div></div><p>js面试中，经常会考的一道数组去重题目，就可以使用Set集合的不可重复性来处理。经测试只能去重下面3种类型的数据。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">,</span> <span class="kc">null</span><span class="p">,</span> <span class="kc">null</span><span class="p">]</span>
    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">(</span><span class="nx">arr</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="kd">set</span><span class="p">))</span> <span class="c1">// [1, 'haha', null]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">([...</span><span class="kd">set</span><span class="p">])</span> <span class="c1">// [1, 'haha', null]</span>
</code></pre></div></div><h4 id="weak-set集合">Weak Set集合</h4><p>Set集合本身是强引用，只要new Set()实例化的引用存在，就不释放内存，这样一刀切肯定不好啊，比如你定义了一个DOM元素的Set集合，然后在某个js中引用了该实例，但是当页面关闭或者跳转时，你希望该引用应立即释放内存，Set不听话，那好，你还可以使用 Weak Set</p><p><strong>语法：</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">new</span> <span class="nb">WeakSet</span><span class="p">([</span><span class="nx">iterable</span><span class="p">]);</span>
</code></pre></div></div><p><strong>和Set的区别</strong></p><p>1、<code class="language-plaintext highlighter-rouge">WeakSet 对象中只能存放对象值</code>, 不能存放原始值, 而 Set 对象都可以.</p><p>2、WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code class="language-plaintext highlighter-rouge">WeakSet 对象是无法被枚举的</code>, 没有办法拿到它包含的所有元素.</p><p><strong>使用</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="kd">set</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakSet</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">class_1</span> <span class="o">=</span> <span class="p">{},</span> <span class="nx">class_2</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">class_1</span><span class="p">);</span>
    <span class="kd">set</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">class_2</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">)</span> <span class="c1">// WeakSet {Object {}, Object {}}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">class_1</span><span class="p">))</span> <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="kd">set</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">class_2</span><span class="p">))</span> <span class="c1">// true</span>
</code></pre></div></div><h4 id="map">Map</h4><blockquote><p>Map是存储许多键值对的有序列表，key和value支持所有数据类型。</p></blockquote><p><strong>创建Map</strong></p><p>如果说Set像数组，那么Map更像对象。而对象中的key只支持字符串，Map更加强大，支持所有数据类型，不管是数字、字符串、Symbol等。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// 一个空Map集合</span>
    <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
</code></pre></div></div><p>对比Set集合的原型，<strong>Map集合的原型多了set()和get()方法</strong>，注意set()和Set集合不是一个东西。Map没有add，使用set()添加key，value，在Set集合中，使用add()添加value，没有key。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
    <span class="c1">// 输出结果</span>
    <span class="nb">Map</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">haha</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">id</span><span class="dl">"</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">}</span>
        <span class="nl">size</span><span class="p">:(...)</span>
        <span class="nx">__proto__</span><span class="p">:</span><span class="nb">Map</span>
        <span class="p">[[</span><span class="nx">Entries</span><span class="p">]]:</span><span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="mi">0</span><span class="p">:{</span><span class="dl">"</span><span class="s2">name</span><span class="dl">"</span> <span class="o">=&gt;</span> <span class="dl">"</span><span class="s2">haha</span><span class="dl">"</span><span class="p">}</span>
            <span class="mi">1</span><span class="p">:{</span><span class="dl">"</span><span class="s2">id</span><span class="dl">"</span> <span class="o">=&gt;</span> <span class="mi">10</span><span class="p">}</span>
        <span class="nl">length</span><span class="p">:</span><span class="mi">2</span>

    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// 10</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// "haha"</span>
</code></pre></div></div><p><strong>使用对象做key</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="dl">'</span><span class="s1">谁知道这是个什么玩意</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span> <span class="c1">// 谁知道这是个什么玩意</span>
</code></pre></div></div><p><strong>Map同样可以使用forEach遍历key、value</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="dl">'</span><span class="s1">这是个什么玩意</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">haha</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">id</span><span class="dl">'</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="nx">map</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="p">})</span>
    
    <span class="c1">//Object {} "这是个什么玩意"</span>
    <span class="c1">//"name" "haha"</span>
    <span class="c1">//"id" 1</span>
</code></pre></div></div><h4 id="weak-map">Weak Map</h4><p>有强Map，就有弱鸡Map。</p><p>和Set要解决的问题一样，希望不再引用Map的时候自动触发垃圾回收机制。那么，你就需要Weak Map。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">map</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">WeakMap</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.header</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">map</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="dl">'</span><span class="s1">这是个什么玩意</span><span class="dl">'</span><span class="p">);</span>
    
    <span class="nx">map</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span> <span class="c1">// "这是个什么玩意"</span>
    
    <span class="c1">//移除该元素</span>
    <span class="nx">key</span><span class="p">.</span><span class="nx">parentNode</span><span class="p">.</span><span class="nx">removeChild</span><span class="p">(</span><span class="nx">key</span><span class="p">);</span>
    <span class="nx">key</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
</code></pre></div></div><p><strong>总结</strong></p><p>Set集合可以用来过滤数组中重复的元素，只能通过has方法检测指定的值是否存在，或者是通过forEach处理每个值。</p><p>Weak Set集合存放对象的弱引用，当该对象的其他强引用被清除时，集合中的弱引用也会自动被垃圾回收机制回收，追踪成组的对象是该集合最好的使用方式。</p><p>Map集合通过set()添加键值对，通过get()获取键值，你可以把它看成是比Object更加强大的对象。</p><p>Weak Map集合只支持对象类型的key，所有key都是弱引用，当该对象的其他强引用被清除时，集合中的弱引用也会自动被垃圾回收机制回收，为那些实际使用与生命周期管理分离的对象添加额外信息是非常适合的使用方式。</p><h3 id="八迭代器iterator">八、迭代器（Iterator）</h3><h4 id="迭代器">迭代器</h4><p><strong>ES5实现迭代器</strong></p><blockquote><p>迭代器是一种特殊对象，每一个迭代器对象都有一个next()，该方法返回一个对象，包括value和done属性。</p></blockquote><p><strong>ES5实现迭代器的代码如下：</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//实现一个返回迭代器对象的函数，注意该函数不是迭代器，返回结果才叫做迭代器。</span>
    <span class="kd">function</span> <span class="nx">createIterator</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">next</span><span class="p">()</span> <span class="p">{</span>
          <span class="kd">var</span> <span class="nx">done</span> <span class="o">=</span> <span class="p">(</span><span class="nx">i</span> <span class="o">&gt;=</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span> <span class="c1">// 判断i是否小于遍历的对象长度。</span>
          <span class="kd">var</span> <span class="nx">value</span> <span class="o">=</span> <span class="o">!</span><span class="nx">done</span> <span class="p">?</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="o">++</span><span class="p">]</span> <span class="p">:</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">//如果done为false，设置value为当前遍历的值。</span>
          <span class="k">return</span> <span class="p">{</span>
            <span class="nx">done</span><span class="p">,</span>
            <span class="nx">value</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    
    <span class="c1">//该方法返回的最终是一个对象，包含value、done属性。</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 1, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 2, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 3, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: undefined, done: true}</span>
</code></pre></div></div><h4 id="生成器generator">生成器（Generator）</h4><p><strong>生成器是函数：用来返回迭代器。</strong></p><p>这个概念有2个关键点，一个是函数、一个是返回迭代器。这个函数不是上面ES5中创建迭代器的函数，而是ES6中特有的，一个带有*（星号）的函数，同时你也需要使用到yield。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//生成器函数，ES6内部实现了迭代器功能，你要做的只是使用yield来迭代输出。</span>
    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 1, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 2, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 3, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: undefined, done: true}</span>
</code></pre></div></div><p>生成器的yield关键字有个神奇的功能，就是当你执行一次next()，那么只会执行一个yield后面的内容，然后语句终止运行。</p><p><strong>在for循环中使用迭代器</strong></p><p>即使你是在for循环中使用yield关键字，也会暂停循环。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">items</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>  <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">items</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//{value: 1, done: false}</span>
</code></pre></div></div><p><strong>yield使用限制</strong></p><p>yield只可以在生成器函数内部使用，如果在非生成器函数内部使用，则会报错。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">(</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//你应该在这里使用yield</span>
      <span class="nx">items</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">value</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">value</span> <span class="c1">//语法错误，在map的回调函数里面使用了yield</span>
      <span class="p">})</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//无输出</span>
</code></pre></div></div><p><strong>生成器函数表达式</strong></p><p>函数表达式很简单，就是下面这种写法，也叫匿名函数，不用纠结。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">createIterator</span> <span class="o">=</span> <span class="kd">function</span> <span class="o">*</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>
</code></pre></div></div><p><strong>在对象中添加生成器函数</strong></p><p>一个对象长这样：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{}</span>
</code></pre></div></div><p>我们可以在obj中添加一个生成器，也就是添加一个带星号的方法：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">createIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span>  <span class="c1">//{value: 1, done: false}</span>
</code></pre></div></div><p><strong>可迭代对象和for of循环</strong></p><p>再次默读一遍，迭代器是对象，生成器是返回迭代器的函数。</p><p>凡是通过生成器生成的迭代器，都是可以迭代的对象(可迭代对象具有Symbol.iterator属性)，也就是可以通过for of将value遍历出来。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">value</span> <span class="k">of</span> <span class="nx">a</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 1 2 3</span>
</code></pre></div></div><p>上面的例子告诉我们生成器函数返回的迭代器是一个可以迭代的对象。其实我们这里要研究的是Symbol.iterator的用法。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
      <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span> <span class="c1">//a是一个迭代器</span>
    <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">a</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span><span class="c1">//使用Symbol.iterator访问迭代器</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">.</span><span class="nx">next</span><span class="p">())</span> <span class="c1">//{value: 1, done: false}</span>
</code></pre></div></div><p>Symbol.iterator还可以用来检测一个对象是否可迭代</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typeof</span> <span class="nx">obj</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span>
</code></pre></div></div><h4 id="创建可迭代对象">创建可迭代对象</h4><p>在ES6中，数组、Set、Map、字符串都是可迭代对象。</p><p>默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">items</span><span class="p">:</span> <span class="p">[]</span>
    <span class="p">}</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="c1">//这样子虽然向数组添加了新元素，但是obj不可迭代</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// _iterator[Symbol.iterator] is not a function</span>
    <span class="p">}</span>

    <span class="c1">//接下来给obj添加一个生成器，使obj成为一个可以迭代的对象。</span>
    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">items</span><span class="p">:</span> <span class="p">[],</span>
      <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">item</span> <span class="k">of</span> <span class="k">this</span><span class="p">.</span><span class="nx">items</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">yield</span> <span class="nx">item</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">obj</span><span class="p">.</span><span class="nx">items</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">//现在可以通过for of迭代obj了。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">x</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div><h4 id="内建迭代器">内建迭代器</h4><p>上面提到了，数组、Set、Map都是可迭代对象，即它们内部实现了迭代器，并且提供了3种迭代器函数调用。</p><p>1、entries() 返回迭代器：<strong>返回键值对</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数组</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// [0, 'a'] [1, 'b'] [2, 'c']</span>
    
    <span class="c1">//Set</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">]);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// ['a', 'a'] ['b', 'b'] ['c', 'c']</span>

    <span class="c1">//Map</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="nx">arr</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">arr</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">entries</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// ['a', 'a'] ['b', 'b']</span>
</code></pre></div></div><p>2、values() 返回迭代器：<strong>返回键值对的value</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数组</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">//'a' 'b' 'c'</span>

    <span class="c1">//Set</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">]);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 'a' 'b' 'c'</span>

    <span class="c1">//Map</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="nx">arr</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">arr</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">values</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 'a' 'b'</span>
</code></pre></div></div><p>3、keys() 返回迭代器：<strong>返回键值对的key</strong></p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数组</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">];</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 0 1 2</span>
    
    <span class="c1">//Set</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="p">([</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">c</span><span class="dl">'</span><span class="p">]);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 'a' 'b' 'c'</span>

    <span class="c1">//Map</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">();</span>
    <span class="nx">arr</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">arr</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">keys</span><span class="p">())</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 'a' 'b'</span>
</code></pre></div></div><p>虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。</p><h4 id="for-of循环解构">for of循环解构</h4><p>对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
      <span class="na">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
      <span class="o">*</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="k">in</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">yield</span> <span class="p">[</span><span class="nx">i</span><span class="p">,</span> <span class="nx">obj</span><span class="p">[</span><span class="nx">i</span><span class="p">]]</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="p">[</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">]</span> <span class="k">of</span> <span class="nx">obj</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">value</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 'a' 1, 'b' 2</span>
</code></pre></div></div><h4 id="字符串迭代器">字符串迭代器</h4><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">abc</span><span class="dl">'</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">v</span> <span class="k">of</span> <span class="nx">str</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="c1">// 'a' 'b' 'c'</span>
</code></pre></div></div><h4 id="nodelist迭代器">NodeList迭代器</h4><p>迭代器真是无处不在啊，dom节点的迭代器你应该已经用过了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">divs</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementsByTagName</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">d</span> <span class="k">of</span> <span class="nx">divs</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div><h4 id="展开运算符和迭代器">展开运算符和迭代器</h4><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">];</span>
    <span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">b</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="c1">// [1, 2, 3, 4, 5, 6]</span>
</code></pre></div></div><h4 id="高级迭代器功能">高级迭代器功能</h4><p>1、传参</p><p>生成器里面有2个yield，当执行第一个next()的时候，返回value为1，然后给第二个next()传入参数10，传递的参数会替代掉上一个next()的yield返回值。在下面的例子中就是first。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">yield</span> <span class="nx">first</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// {value: 1, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="mi">10</span><span class="p">));</span> <span class="c1">// {value: 12, done: false}</span>
</code></pre></div></div><p>2、在迭代器中抛出错误</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">yield</span> <span class="nx">first</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// {value: 1, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="k">throw</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">error</span><span class="dl">'</span><span class="p">)));</span> <span class="c1">// error</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">//不再执行</span>
</code></pre></div></div><p>3、生成器返回语句</p><p>生成器中添加return表示退出操作。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">createIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">first</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span><span class="p">;</span>
      <span class="k">yield</span> <span class="nx">first</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">createIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// {value: 1, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// {value: undefined, done: true}</span>
</code></pre></div></div><p>4、委托生成器</p><p>生成器嵌套生成器</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="o">*</span><span class="nx">aIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="o">*</span><span class="nx">bIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="o">*</span><span class="nx">cIterator</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">yield</span> <span class="o">*</span><span class="nx">aIterator</span><span class="p">()</span>
      <span class="k">yield</span> <span class="o">*</span><span class="nx">bIterator</span><span class="p">()</span>
    <span class="p">}</span>
    
    <span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="nx">cIterator</span><span class="p">();</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// {value: 1, done: false}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">next</span><span class="p">());</span> <span class="c1">// {value: 2, done: false}</span>
</code></pre></div></div><h4 id="异步任务执行器">异步任务执行器</h4><p>ES6之前，我们使用异步的操作方式是调用函数并执行回调函数。</p><p>书上举的例子挺好的，在nodejs中，有一个读取文件的操作，使用的就是回调函数的方式。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>
    <span class="nx">fs</span><span class="p">.</span><span class="nx">readFile</span><span class="p">(</span><span class="dl">"</span><span class="s2">xx.json</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">contents</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//在回调函数中做一些事情</span>
    <span class="p">})</span>
</code></pre></div></div><blockquote><p>任务执行器是一个函数，用来循环执行生成器，因为我们知道生成器需要执行N次next()方法，才能运行完，所以我们需要一个自动任务执行器帮我们做这些事情，这就是任务执行器的作用。</p></blockquote><p>下面我们编写一个异步任务执行器。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//taskDef是一个生成器函数，run是异步任务执行器</span>
    <span class="kd">function</span> <span class="nx">run</span><span class="p">(</span><span class="nx">taskDef</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">task</span> <span class="o">=</span> <span class="nx">taskDef</span><span class="p">();</span> <span class="c1">//调用生成器</span>
      <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="nx">task</span><span class="p">.</span><span class="nx">next</span><span class="p">();</span> <span class="c1">//执行生成器的第一个next()，返回result</span>
      <span class="kd">function</span> <span class="nx">step</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">result</span><span class="p">.</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">//如果done为false，则继续执行next()，并且循环step，直到done为true退出。</span>
          <span class="nx">result</span> <span class="o">=</span> <span class="nx">task</span><span class="p">.</span><span class="nx">next</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
          <span class="nx">step</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="nx">step</span><span class="p">();</span> <span class="c1">//开始执行step()</span>
    <span class="p">}</span>
</code></pre></div></div><p>测试一下我们编写的run方法，我们不再需要console.log N个next了，因为run执行器已经帮我们做了循环执行操作：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">run</span><span class="p">(</span><span class="kd">function</span> <span class="o">*</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">value</span> <span class="o">=</span> <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
      <span class="nx">value</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">20</span><span class="p">;</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 21</span>
    <span class="p">})</span>
</code></pre></div></div><h4 id="总结">总结</h4><p>本章讲了3个概念，迭代器、生成器、任务执行器。</p><p>迭代器是一个对象。</p><p>生成器是一个函数，它最终返回迭代器。</p><p>任务执行器一个函数（或者也叫生成器的回调函数），帮我们自动执行生成器的内部运算，最终返回迭代器。</p><p><br /> <br /></p><h3 id="九类">九、类</h3><p><strong>ES5中的近类结构</strong></p><p>ES5以及之前的版本，没有类的概念，但是聪明的JavaScript开发者，为了实现面向对象，创建了特殊的近类结构。</p><p>ES5中创建类的方法：新建一个构造函数，定义一个方法并且赋值给构造函数的原型。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="dl">'</span><span class="s1">use strict</span><span class="dl">'</span><span class="p">;</span>
    <span class="c1">//新建构造函数，默认大写字母开头</span>
    <span class="kd">function</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//定义一个方法并且赋值给构造函数的原型</span>
    <span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">sayName</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">};</span>
    
    <span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">eryue</span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">sayName</span><span class="p">()</span> <span class="c1">// eryue</span>
    <span class="p">);</span>
</code></pre></div></div><p><strong>ES6 class类</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">Person</span> <span class="p">{</span>
      <span class="c1">//新建构造函数</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="c1">//私有属性</span>
      <span class="p">}</span>
      <span class="c1">//定义一个方法并且赋值给构造函数的原型</span>
      <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Person</span><span class="p">(</span><span class="dl">'</span><span class="s1">eryue</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">sayName</span><span class="p">())</span> <span class="c1">// eryue</span>
</code></pre></div></div><p>和ES5中使用构造函数不同的是，在ES6中，我们将原型的实现写在了类中，但本质上还是一样的，都是需要新建一个类名，然后实现构造函数，再实现原型方法。</p><p><strong>私有属性：</strong>在class中实现私有属性，只需要在构造方法中定义this.xx = xx。</p><p><strong>类声明和函数声明的区别和特点</strong></p><p>1、函数声明可以被提升，类声明不能提升。</p><p>2、类声明中的代码自动强行运行在严格模式下。</p><p>3、类中的所有方法都是不可枚举的，而自定义类型中，可以通过Object.defineProperty()手工指定不可枚举属性。</p><p>4、每个类都有一个[[construct]]的方法。</p><p>5、只能使用new来调用类的构造函数。</p><p>6、不能在类中修改类名。</p><p><strong>类表达式</strong></p><p>类有2种表现形式：声明式和表达式。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//声明式</span>
    <span class="kd">class</span> <span class="nx">B</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}</span>

    <span class="c1">//匿名表达式</span>
    <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="kd">class</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}</span>
    
    <span class="c1">//命名表达式，B可以在外部使用，而B1只能在内部使用</span>
    <span class="kd">let</span> <span class="nx">B</span> <span class="o">=</span> <span class="kd">class</span> <span class="nx">B1</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>类是一等公民</strong></p><p>JavaScript函数是一等公民，类也设计成一等公民。</p><p>1、可以将类作为参数传入函数。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//新建一个类</span>
    <span class="kd">let</span> <span class="nx">A</span> <span class="o">=</span> <span class="kd">class</span> <span class="p">{</span>
      <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="dl">'</span><span class="s1">eryue</span><span class="dl">'</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">//该函数返回一个类的实例</span>
    <span class="kd">function</span> <span class="nx">test</span><span class="p">(</span><span class="nx">classA</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nx">classA</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="c1">//给test函数传入A</span>
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="nx">test</span><span class="p">(</span><span class="nx">A</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">sayName</span><span class="p">())</span> <span class="c1">// eryue</span>
</code></pre></div></div><p>2、通过立即调用类构造函数可以创建单例。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="kd">class</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
      <span class="p">}</span>
      <span class="nx">sayName</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
      <span class="p">}</span>
    <span class="p">}(</span><span class="dl">'</span><span class="s1">eryue</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">sayName</span><span class="p">())</span> <span class="c1">// eryue</span>
</code></pre></div></div><p><strong>访问器属性</strong></p><p>类支持在原型上定义访问器属性。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="nx">state</span>
      <span class="p">}</span>
      <span class="c1">// 创建getter</span>
      <span class="kd">get</span> <span class="nx">myName</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">name</span>
      <span class="p">}</span>
      <span class="c1">// 创建setter</span>
      <span class="kd">set</span> <span class="nx">myName</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// 获取指定对象的自身属性描述符。自身属性描述符是指直接在对象上定义（而非从对象的原型继承）的描述符。</span>
    <span class="kd">let</span> <span class="nx">desriptor</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">getOwnPropertyDescriptor</span><span class="p">(</span><span class="nx">A</span><span class="p">.</span><span class="nx">prototype</span><span class="p">,</span> <span class="dl">"</span><span class="s2">myName</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">get</span><span class="dl">"</span> <span class="k">in</span> <span class="nx">desriptor</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">desriptor</span><span class="p">.</span><span class="nx">enumerable</span><span class="p">)</span> <span class="c1">// false 不可枚举</span>
</code></pre></div></div><p><strong>可计算成员名称</strong></p><p>可计算成员是指使用方括号包裹一个表达式，如下面定义了一个变量m，然后使用[m]设置为类A的原型方法。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">m</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">sayName</span><span class="dl">"</span>
    <span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
      <span class="p">}</span>
      <span class="p">[</span><span class="nx">m</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">name</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="dl">"</span><span class="s2">eryue</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">sayName</span><span class="p">())</span> <span class="c1">// eryue</span>
</code></pre></div></div><p><strong>生成器方法</strong></p><p>回顾一下上一章讲的生成器，生成器是一个返回迭代器的函数。在类中，我们也可以使用生成器方法。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="o">*</span><span class="nx">printId</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span>
    <span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">printId</span><span class="p">()</span>
    
    <span class="nx">x</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// {done: false, value: 1}</span>
    <span class="nx">x</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// {done: false, value: 2}</span>
    <span class="nx">x</span><span class="p">.</span><span class="nx">next</span><span class="p">()</span> <span class="c1">// {done: false, value: 3}</span>
</code></pre></div></div><p>这个写法很有趣，我们新增一个原型方法稍微改动一下。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="o">*</span><span class="nx">printId</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">yield</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">yield</span> <span class="mi">3</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">//从render方法访问printId，很熟悉吧，这就是react中经常用到的写法。</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">printId</span><span class="p">()</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">render</span><span class="p">().</span><span class="nx">next</span><span class="p">())</span> <span class="c1">// {done: false, value: 1}</span>
</code></pre></div></div><h4 id="静态成员">静态成员</h4><p>静态成员是指在方法名或属性名前面加上static关键字，和普通方法不一样的是，static修饰的方法不能在实例中访问，只能在类中直接访问。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
      <span class="p">}</span>
      <span class="kd">static</span> <span class="nx">create</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nx">A</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="nx">A</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="dl">"</span><span class="s2">eryue</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// eryue</span>
    
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="dl">"</span><span class="s2">eryue</span><span class="dl">"</span><span class="p">))</span> <span class="c1">// t.create is not a function</span>
</code></pre></div></div><h4 id="继承与派生类">继承与派生类</h4><p>我们在写react的时候，自定义的组件会继承React.Component。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">A</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
       <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">){</span>
           <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
       <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>A叫做派生类</strong>，在派生类中，如果使用了构造方法，就必须使用super()。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span>
      <span class="p">}</span>
      <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">class</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">add</span><span class="p">())</span> <span class="c1">// 5</span>
</code></pre></div></div><p><strong>关于super使用的几点要求</strong></p><p>1、只可以在派生类中使用super。派生类是指继承自其它类的新类。</p><p>2、在构造函数中访问this之前要调用super()，负责初始化this。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1">// 错误，必须先写super()</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><p>3、如果不想调用super，可以让类的构造函数返回一个对象。</p><p>我们可以在继承的类中重写父类的方法。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span>
      <span class="p">}</span>
      <span class="c1">//父类的add方法，求和</span>
      <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span>
      <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="kd">class</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="c1">//重写add方法，求积</span>
      <span class="nx">add</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">*</span> <span class="k">this</span><span class="p">.</span><span class="nx">b</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">t</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">T</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">add</span><span class="p">())</span> <span class="c1">// 6</span>
</code></pre></div></div><h4 id="静态成员继承">静态成员继承</h4><p><strong>父类中的静态成员，也可以继承到派生类中。</strong>静态成员继承只能通过派生类访问，不能通过派生类的实例访问。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="nx">a</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">b</span> <span class="o">=</span> <span class="nx">b</span>
      <span class="p">}</span>
      <span class="kd">static</span> <span class="nx">printSum</span><span class="p">([</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">]</span> <span class="o">=</span> <span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">class</span> <span class="nx">T</span> <span class="kd">extends</span> <span class="nx">Component</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">T</span><span class="p">.</span><span class="nx">printSum</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]))</span> <span class="c1">// 5</span>
</code></pre></div></div><h4 id="内建对象的继承">内建对象的继承</h4><p>有些牛逼的人觉得使用内建的Array不够爽，就希望ECMA提供一种继承内建对象的方法，然后那帮大神们就把这个功能添加到class中了。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">MyArray</span> <span class="kd">extends</span> <span class="nb">Array</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">colors</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">MyArray</span><span class="p">()</span>
    <span class="nx">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">colors</span><span class="p">)</span> <span class="c1">// [1]</span>
</code></pre></div></div><p><strong>Symbol.species</strong></p><p>该用法我还没有接触过，目前只知道在内建对象中使用了该方法，如果在类中调用this.constructor，使用Symbol.species可以让派生类重写返回类型。</p><h4 id="在构造函数中使用newtarget">在构造函数中使用new.target</h4><p>new.target通常表示当前的构造函数名。通常我们使用new.target来阻止直接实例化基类，下面是这个例子的实现。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">A</span> <span class="p">{</span>
      <span class="kd">constructor</span><span class="p">()</span> <span class="p">{</span>
      <span class="c1">//如果当前的new.target为A类，就抛出异常</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">new</span><span class="p">.</span><span class="nx">target</span> <span class="o">===</span> <span class="nx">A</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">error haha</span><span class="dl">"</span><span class="p">)</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A</span><span class="p">()</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// error haha</span>
</code></pre></div></div><h4 id="总结-1">总结</h4><p>本章只有一个知识点，那就是class的使用，最开始的声明class，到后面的继承派生类，都是非常常用的写法，还有静态成员的使用。</p><p><br /> <br /></p><h3 id="十promise">十、Promise</h3><p><strong>为什么要异步编程</strong></p><p>我们在写前端代码时，经常会对dom做事件处理操作，比如点击、激活焦点、失去焦点等；再比如我们用ajax请求数据，使用回调函数获取返回值。这些都属于异步编程。</p><p>也许你已经大概知道JavaScript引擎单线程的概念，那么这种单线程模式和异步编程有什么关系呢？</p><blockquote><p>JavaScript引擎中，只有一个主线程，当执行JavaScript代码块时，不允许其他代码块执行，而事件机制和回调机制的代码块会被添加到任务队列中，当符合某个触发回调或者事件的时候，就会执行该事件或者回调函数。</p></blockquote><p><strong>事件模型</strong></p><p>浏览器初次渲染DOM的时候，我们会给一些DOM绑定事件函数，只有当触发了这些DOM事件函数，才会执行他们。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">btn</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="dl">'</span><span class="s1">.button</span><span class="dl">'</span><span class="p">)</span>
    <span class="nx">btn</span><span class="p">.</span><span class="nx">onclick</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>回调模式</strong> nodejs中可能非常常见这种回调模式，但是对于前端来说，ajax的回调是最熟悉不过了。ajax回调有多个状态，当响应成功和失败都有不同的回调函数。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">'</span><span class="s1">/router</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
    <span class="p">})</span>
</code></pre></div></div><p>回调也可能带来一个问题，那就是地狱回调，不过幸运的是，我从进入前端界开始，就使用react，跳过了很多坑，特别是地狱回调，一直没有机会在工作中遇见到，真是遗憾。</p><p><strong>Promise</strong></p><p>事件函数没有问题，我们用的很爽，问题出在回调函数，尤其是指地狱回调，Promise的出现正是为了避免地狱回调带来的困扰。</p><p><strong>Promise是什么</strong></p><p>Promise的中文意思是承诺，也就是说，JavaScript对你许下一个承诺，会在未来某个时刻兑现承诺。</p><p><strong>Promise生命周期</strong></p><p>react有生命周期，vue也有生命周期，就连Promise也有生命周期，现在生命周期咋这么流行了。</p><p><strong>Promise的生命周期：进行中（pending），已经完成（fulfilled），拒绝（rejected）</strong></p><p>Promise被称作异步结果的占位符，它不能直接返回异步函数的执行结果，需要使用then()，当获取异常回调的时候，使用catch()。</p><p>这次我们使用axios插件的代码做例子。axios是前端比较热门的http请求插件之一。</p><p>1、创建axios实例instance。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">import</span> <span class="nx">axios</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">axios</span><span class="dl">'</span>
    <span class="k">export</span> <span class="kd">const</span> <span class="nx">instance</span> <span class="o">=</span> <span class="nx">axios</span><span class="p">.</span><span class="nx">create</span><span class="p">()</span>
</code></pre></div></div><p>2、使用axios实例 + Promise获取返回值。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">promise</span> <span class="o">=</span> <span class="nx">instance</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">url</span><span class="dl">'</span><span class="p">)</span>
    
    <span class="nx">promise</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">result</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">result</span><span class="p">)).</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">))</span>
</code></pre></div></div><p><strong>使用Promise构建函数创建新的Promise</strong></p><p>Promise构造函数只有一个参数，该参数是一个函数，被称作执行器，执行器有2个参数，分别是resolve()和reject()，一个表示成功的回调，一个表示失败的回调。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">5</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 5</span>
</code></pre></div></div><p><strong>记住，Promise实例只能通过resolve或者reject函数来返回，并且使用then()或者catch()获取，不能在new Promise里面直接return，这样是获取不到Promise返回值的。</strong></p><p>1、我们也可以使用Promise直接resolve(value)。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Promise</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 5</span>
</code></pre></div></div><p>2、也可以使用reject(value)</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 5</span>
</code></pre></div></div><p>3、执行器错误通过catch捕捉。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">error!!</span><span class="dl">'</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}).</span><span class="k">catch</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">message</span><span class="p">))</span> <span class="c1">// error!!</span>
</code></pre></div></div><p><strong>全局的Promise拒绝处理</strong></p><p>这里涉及到nodejs环境和浏览器环境的全局，主要说的是如果执行了Promise.reject()，浏览器或者node环境并不会强制报错，只有在你调用catch的时候，才能知道Promise被拒绝了。</p><p>这种行为就像是，你写了一个函数，函数内部有true和false两种状态，而我们希望false的时候抛出错误，但是在Promise中，并不能直接抛出错误， 无论Promise是成功还是拒绝状态，你获取Promise生命周期的方法只能通过then()和catch()。</p><p><strong>nodejs环境：</strong></p><p>node环境下有个对象叫做process，即使你没写过后端node，如果写过前端node服务器，也应该知道可以使用process.ENV_NODE获取环境变量。为了监听Promise的reject（拒绝）情况，NodeJS提供了一个process.on()，类似jQuery的on方法，事件绑定函数。</p><p>process.on()有2个事件</p><p>unhandledRjection:在一个事件循环中，当Promise执行reject()，并且没有提供catch()时被调用。</p><p>正常情况下，你可以使用catch捕捉reject。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="dl">"</span><span class="s2">It was my wrong!</span><span class="dl">"</span><span class="p">).</span><span class="k">catch</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span>
</code></pre></div></div><p>但是，有时候你不总是记得使用catch。你就需要使用process.on()</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">rejected</span>
    <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="dl">"</span><span class="s2">It was my wrong!</span><span class="dl">"</span><span class="p">)</span>
    
    <span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">unhandledRjection</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">reason</span><span class="p">,</span> <span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reason</span><span class="p">.</span><span class="nx">message</span><span class="p">)</span> <span class="c1">// It was my wrong!</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rejected</span> <span class="o">===</span> <span class="nx">promise</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="p">})</span>
</code></pre></div></div><p>rejectionHandled:在一个事件循环后，当Promise执行reject，并且没有提供catch()时被调用。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">rejected</span>
    <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">It was my wrong!</span><span class="dl">"</span><span class="p">))</span>
    
    <span class="nx">process</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="dl">"</span><span class="s2">rejectionHandled</span><span class="dl">"</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">promise</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">rejected</span> <span class="o">===</span> <span class="nx">promise</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="p">})</span>
</code></pre></div></div><p><strong>异同：</strong></p><p>事件循环中、事件循环后，你可能很难理解这2个的区别，但是这不重要，重要的是，如果你通过了catch()方法来捕捉reject操作，那么，这2个事件就不会生效。</p><p><strong>浏览器环境：</strong></p><p>和node环境一样，都提供了unhandledRjection、rejectionHandled事件，不同的是浏览器环境是通过window对象来定义事件函数。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">rejected</span>
    <span class="nx">rejected</span> <span class="o">=</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">"</span><span class="s2">It was my wrong!</span><span class="dl">"</span><span class="p">))</span>
    
    <span class="nb">window</span><span class="p">.</span><span class="nx">rejectionHandled</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="c1">// true</span>
    <span class="p">}</span>
    <span class="nx">rejectionHandled</span><span class="p">()</span>
</code></pre></div></div><p><strong>Promise链式调用</strong></p><p>这个例子中，使用了3个then，第一个then返回 s * s，第二个then捕获到上一个then的返回值，最后一个then直接输出end。这就叫链式调用，很好理解的。我只使用了then()，实际开发中，你还应该加上catch()。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">try</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
      <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">reject</span><span class="p">(</span><span class="dl">'</span><span class="s1">It was my wrong!!!</span><span class="dl">'</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}).</span><span class="nx">then</span><span class="p">(</span><span class="nx">s</span> <span class="o">=&gt;</span> <span class="nx">s</span> <span class="o">*</span> <span class="nx">s</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">s2</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s2</span><span class="p">)).</span><span class="nx">then</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">))</span>
    <span class="c1">// 25  "end"</span>
</code></pre></div></div><p><strong>Promise的其他方法</strong></p><p>在Promise的构造函数中，除了reject()和resolve()之外，还有2个方法，Promise.all()、Promise.race()。</p><p><strong>Promise.all()</strong></p><p>前面我们的例子都是只有一个Promise，现在我们使用all()方法包装多个Promise实例。</p><p>语法很简单：参数只有一个，可迭代对象，可以是数组，或者Symbol类型等。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">(</span><span class="nx">iterable</span><span class="p">).</span><span class="nx">then</span><span class="p">().</span><span class="k">catch</span><span class="p">()</span>
</code></pre></div></div><p>示例：传入3个Promise实例</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="p">}),</span>
      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
      <span class="p">}),</span>
      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="nx">arr</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span> <span class="c1">// [1, 2, 3]</span>
    <span class="p">})</span>
</code></pre></div></div><p><strong>Promise.race()</strong>语法和all()一样，但是返回值有所不同，race根据传入的多个Promise实例，只要有一个实例resolve或者reject，就只返回该结果，其他实例不再执行。</p><p>还是使用上面的例子，只是我给每个resolve加了一个定时器，最终结果返回的是3，因为第三个Promise最快执行。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nb">Promise</span><span class="p">.</span><span class="nx">race</span><span class="p">([</span>
      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1000</span><span class="p">)</span>
      <span class="p">}),</span>
      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="mi">100</span><span class="p">)</span>
      <span class="p">}),</span>
      <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">resolve</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">10</span><span class="p">)</span>
      <span class="p">})</span>
    <span class="p">]).</span><span class="nx">then</span><span class="p">(</span><span class="nx">value</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span> <span class="c1">// 3</span>
    <span class="p">})</span>
</code></pre></div></div><p><strong>Promise派生</strong></p><p>派生的意思是定义一个新的Promise对象，继承Promise方法和属性。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">class</span> <span class="nx">MyPromise</span> <span class="kd">extends</span> <span class="nb">Promise</span> <span class="p">{</span>
    
      <span class="c1">//重新封装then()</span>
      <span class="nx">success</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="c1">//重新封装catch()</span>
      <span class="nx">failer</span><span class="p">(</span><span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">reject</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><p>接着我们来使用一下这个派生类。 ​</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">new</span> <span class="nx">MyPromise</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="nx">reject</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">resolve</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="p">}).</span><span class="nx">success</span><span class="p">(</span><span class="nx">v</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">v</span><span class="p">))</span> <span class="c1">// 10</span>
</code></pre></div></div><p>如果只是派生出来和then、catch一样的方法，我想，你不会干这么无聊的事情。</p><p><strong>Promise和异步的联系</strong></p><p>Promise本身不是异步的，只有他的then()或者catch()方法才是异步，也可以说Promise的返回值是异步的。通常Promise被使用在node，或者是前端的ajax请求、前端DOM渲染顺序等地方。</p><p>###比Promise更牛逼的异步方案</p><p>在本章你只需要了解有async这个未来的方案，推荐不会的赶紧去网上找资料学，反正我是已经在实际项目中全面开展async了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">async</span> <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">await</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{}</span>
    <span class="p">}</span>
</code></pre></div></div><p><br /> <br /></p><h3 id="十一proxy代理和-reflection反射-api">十一、Proxy（代理）和 Reflection（反射） API</h3><h4 id="反射的概念">反射的概念</h4><p>Reflect 是一个内置的对象，它提供可拦截JavaScript操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">new</span> <span class="nb">Reflect</span><span class="p">()</span> <span class="c1">//错误的写法</span>
</code></pre></div></div><p><strong>反射的使用</strong></p><p>Reflect提供了一些静态方法，静态方法是指只能通过对象自身访问的的方法</p><p><strong>静态方法列表</strong></p><p>1、Reflect.apply() 2、Reflect.construct() 3、Reflect.defineProperty() 4、Reflect.deleteProperty() 5、Reflect.enumerate() 6、Reflect.get() 7、Reflect.getOwnPropertyDescriptor() 8、Reflect.getPrototypeOf() 9、Reflect.has() 10、Reflect.isExtensible() 11、Reflect.ownKeys() 12、Reflect.preventExtensions() 13、Reflect.set() 14、Reflect.setPrototypeOf()</p><p><strong>静态方法的使用</strong></p><p>demo1：使用Reflect.get()获取目标对象指定key的value。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">a</span><span class="p">:</span> <span class="mi">1</span>
    <span class="p">};</span>
    
    <span class="kd">let</span> <span class="nx">s1</span> <span class="o">=</span> <span class="nb">Reflect</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="dl">"</span><span class="s2">a</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s1</span><span class="p">)</span> <span class="c1">// 1</span>
</code></pre></div></div><p>demo2:使用Reflect.apply给目标函数floor传入指定的参数。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">s2</span> <span class="o">=</span> <span class="nb">Reflect</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">floor</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.75</span><span class="p">]);</span> 
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s2</span><span class="p">)</span> <span class="c1">// 1</span>
</code></pre></div></div><p><strong>进一步理解Reflect</strong></p><p>看了上面的例子和方法，我们知道Reflect可以拦截JavaScript代码，包括拦截对象，拦截函数等，然后对拦截到的对象或者函数进行读写等操作。</p><p>比如demo1的get()方法，拦截obj对象，然后读取key为a的值。当然，不用反射也可以读取a的值。</p><p>再看demo2的apply()方法，这个方法你应该比较了解了，和数组中使用apply不同的是，Reflect.apply()提供了3个参数，第一个参数是反射的函数，后面2个参数才是和数组的apply一致。demo2的例子我们可以理解成是拦截了Math.floor方法，然后传入参数，将返回值赋值给s2，这样我们就能在需要读取这个返回值的时候调用s2。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数组使用apply</span>
    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="kd">function</span> <span class="nx">a</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">concat</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="kc">null</span><span class="p">,</span> <span class="nx">arguments</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">a</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [1, 2 ,3]</span>
</code></pre></div></div><p>其实Reflect的作用和我们下面要讲的Proxy是差不多的。</p><h4 id="代理-proxy">代理 Proxy</h4><p><strong>语法</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">handler</span><span class="p">);</span>
</code></pre></div></div><p>target：一个目标对象(可以是任何类型的对象，包括本机数组，函数，甚至另一个代理)用Proxy来包装。 handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p><p><strong>代理的使用</strong></p><p><strong>基础demo</strong>Proxy的demo有很多，我们只分析基础demo，主要看new Proxy({}, handler)的操作，指定目标obj对象，然后handler对象执行get()操作，get()返回值的判断是，如果name是target目标对象的属性，则返回target[name]的值，否则返回37，最后测试的时候，p.a是对象p的key，所以返回a的value，而p.b不存在，返回37。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">a</span><span class="p">:</span> <span class="mi">10</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">handler</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">get</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">){</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">test: </span><span class="dl">'</span><span class="p">,</span> <span class="nx">target</span><span class="p">,</span> <span class="nx">name</span><span class="p">)</span>
            <span class="c1">// test:  {"a":10} a</span>
            <span class="c1">// test:  {"a":10} b</span>
            <span class="k">return</span> <span class="nx">name</span> <span class="k">in</span> <span class="nx">target</span> <span class="p">?</span> <span class="nx">target</span><span class="p">[</span><span class="nx">name</span><span class="p">]</span> <span class="p">:</span> <span class="mi">37</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Proxy</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">handler</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">a</span><span class="p">,</span> <span class="nx">p</span><span class="p">.</span><span class="nx">b</span><span class="p">)</span> <span class="c1">// 10 37</span>
</code></pre></div></div><p>这个例子的作用是拦截目标对象obj，当执行obj的读写操作时，进入handler函数进行判断，如果读取的key不存在，则返回默认值。</p><p>我们使用一些http-proxy插件或者webpack的时候，有时候需要访问某个api时，跳转到指定的url，这种方式也能解决跨域访问。这种代理模式和Proxy的代理有异曲同工之妙。但是，别混为一体了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="p">{</span>
        <span class="na">devServer</span><span class="p">:</span> <span class="p">{</span>
           <span class="na">proxy</span><span class="p">:</span> <span class="p">[</span>
               <span class="p">{</span>
                    <span class="na">context</span><span class="p">:</span> <span class="dl">"</span><span class="s2">/api/*</span><span class="dl">"</span><span class="p">,</span> <span class="c1">//代理API</span>
                    <span class="na">target</span><span class="p">:</span> <span class="dl">'</span><span class="s1">https://www.hyy.com</span><span class="dl">'</span><span class="p">,</span> <span class="c1">//目标URL</span>
                    <span class="na">secure</span><span class="p">:</span> <span class="kc">false</span>
              <span class="p">}</span>
           <span class="p">]</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div><p><strong>总结</strong></p><p>无论是反射还是代理，除了他们使用方法不同之外，他们所作的事情非常相似，都可以理解成拦截某个东西，然后执行某个函数操作，再返回函数操作的结果。</p><p>大部分前端在日常业务需求中，几乎很少使用到这2个API，实际使用场景还得在以后的开发中慢慢挖掘。</p><p><br /> <br /></p><h3 id="十二模块化">十二、模块化</h3><h4 id="模块的定义">模块的定义</h4><p>模块是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。</p><p>模块可以是函数、数据、类，需要指定导出的模块名，才能被其他模块访问。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数据模块</span>
    <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="c1">//函数模块</span>
    <span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="c1">//类模块</span>
    <span class="kd">class</span> <span class="nx">My</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Components</span> <span class="p">{</span>
    
    <span class="p">}</span>
</code></pre></div></div><h4 id="模块的导出">模块的导出</h4><p>给数据、函数、类添加一个export，就能导出模块。一个配置型的JavaScript文件中，你可能会封装多种函数，然后给每个函数加上一个export关键字，就能在其他文件访问到。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//数据模块</span>
    <span class="k">export</span> <span class="kd">const</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span><span class="na">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="c1">//函数模块</span>
    <span class="k">export</span> <span class="kd">const</span> <span class="nx">sum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="c1">//类模块</span>
    <span class="k">export</span> <span class="kd">class</span> <span class="nx">My</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Components</span> <span class="p">{</span>
    
    <span class="p">}</span>
</code></pre></div></div><h4 id="模块的引用">模块的引用</h4><p>在另外的js文件中，我们可以引用上面定义的模块。使用import关键字，导入分2种情况，一种是导入指定的模块，另外一种是导入全部模块。</p><p>1、导入指定的模块。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//导入obj数据，My类</span>
    <span class="k">import</span> <span class="p">{</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">My</span><span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
    
    <span class="c1">//使用</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">My</span><span class="p">)</span>
</code></pre></div></div><p>2、导入全部模块</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//导入全部模块</span>
    <span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">all</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
    
    <span class="c1">//使用</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">all</span><span class="p">.</span><span class="nx">obj</span><span class="p">,</span> <span class="nx">all</span><span class="p">.</span><span class="nb">sun</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nx">all</span><span class="p">.</span><span class="nx">My</span><span class="p">)</span>
</code></pre></div></div><h4 id="默认模块的使用">默认模块的使用</h4><p>如果给我们的模块加上default关键字，那么该js文件默认只导出该模块，你还需要把大括号去掉。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">//默认模块的定义</span>
    <span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="k">export</span> <span class="k">default</span> <span class="nx">sum</span>
    
    <span class="c1">//导入默认模块</span>
    <span class="k">import</span> <span class="nx">sum</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
</code></pre></div></div><h4 id="模块的使用限制">模块的使用限制</h4><p>不能在语句和函数之内使用export关键字，只能在模块顶部使用，作为react和vue开发者的你，这个限制你应该很熟悉了。</p><p><strong>在react中，模块顶部导入其他模块。</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">import</span> <span class="nx">react</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span>
</code></pre></div></div><p><strong>在vue中，模块顶部导入其他模块。</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">&lt;</span><span class="nx">script</span><span class="o">&gt;</span>
        <span class="k">import</span> <span class="nx">sum</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
    <span class="o">&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div><h4 id="修改模块导入和导出名">修改模块导入和导出名</h4><p>有2种修改方式，一种是模块导出时修改，一种是导入模块时修改。</p><p>1、导出时修改：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="k">export</span> <span class="p">{</span><span class="nx">sum</span> <span class="k">as</span> <span class="nx">add</span><span class="p">}</span>

    <span class="k">import</span> <span class="p">{</span> <span class="nx">add</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
    <span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div><p>2、导入时修改：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="k">export</span> <span class="nx">sum</span>

    <span class="k">import</span> <span class="p">{</span> <span class="nx">sum</span> <span class="k">as</span> <span class="nx">add</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
    <span class="nx">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</code></pre></div></div><h4 id="无绑定导入">无绑定导入</h4><p>当你的模块没有可导出模块，全都是定义的全局变量的时候，你可以使用无绑定导入。</p><p>模块：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="kd">const</span> <span class="nx">PI</span> <span class="o">=</span> <span class="mf">3.1314</span>
</code></pre></div></div><p>无绑定导入：</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">import</span> <span class="dl">'</span><span class="s1">./xx.js</span><span class="dl">'</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">PI</span><span class="p">)</span>
</code></pre></div></div><h4 id="浏览器加载模块">浏览器加载模块</h4><p>有用过webpack打包js模块的同学可能有经验，使用webpack打包了多个js文件，然后放到HTML使用script加载时，如果加载顺序不对，就会出现找不到模块的错误。</p><p>这是因为模块之间是有依赖关系的，就像你使用jQuery的时候，必须先加载jQuery的代码，才能使用jQuery提供的方法。</p><p><strong>加载模块的方法，总是先加载模块1，再加载模块2，因为module类型默认使用defer属性。</strong></p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">module</span><span class="dl">"</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">module1.js</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">script</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">module</span><span class="dl">"</span> <span class="nx">src</span><span class="o">=</span><span class="dl">"</span><span class="s2">module2.js</span><span class="dl">"</span><span class="o">&gt;&lt;</span><span class="sr">/script</span><span class="err">&gt;
</span></code></pre></div></div><p><strong>总结</strong></p><p>模块还有很多有意思的特性，对react和vue开发有一定经验的人对这些基本知识应该了如指掌，新手不了解也不用太心急，写几个module.js做一下尝试。如果浏览器报错，不能识别export模块，你可能需要先加载babel的js插件来编译它。</p><p><br /> <br /></p><h3 id="十三补充知识点">十三、补充（知识点）</h3><p>ES5提供的数组已经很强大，但是ES6中继续改进了一些，主要是增加了新的数组方法，所以这章的知识非常少。</p><h4 id="创建数组">创建数组</h4><p><strong>ES5中创建数组的方式：数组字面量、new一个数组。</strong></p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">//数组字面量</span>
    <span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">()</span> <span class="c1">//new构建</span>
</code></pre></div></div><p><strong>ES6创建数组：Array.of()、Array.from()</strong></p><h4 id="arrayof">Array.of()</h4><p>ES5中new一个人数组的时候，会存在一个令人困惑的情况。当new一个数字的时候，生成的是一个长度为该数字的数组，当new一个字符串的时候，生成的是该字符串为元素的数组。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">a</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">b</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Array</span><span class="p">(</span><span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="c1">//[undefined, undefined] ["2"]</span>
</code></pre></div></div><p>这样一来，导致new Array的行为是不可预测的，Array.of()出现为的就是解决这个情况。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="kd">const</span> <span class="nx">d</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">of</span><span class="p">(</span><span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">)</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span> <span class="c1">// [2] ["2"]</span>
</code></pre></div></div><p>使用Array.of()创建的数组传入的参数都是作为数组的元素，而不在是数组长度，这样就避免了使用上的歧义。</p><h4 id="arrayfrom">Array.from()</h4><p>如果说Array.of()是创建一个新数组，而<strong>Array.from()是将类数组转换成数组</strong>。</p><p>下面的例子讲的是将arguments转换成数组。arguments是类数组对象，他表示的是当前函数的所有参数，如果函数没有参数，那么arguments就为空。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">test</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">)</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">//[1, 2]</span>
</code></pre></div></div><p><strong>映射转换：</strong>Array.from(arg1, arg2)，我们可以给该方法提供2个参数，第二个参数作为第一个参数的转换。看个简单例子你就懂了。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">test</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
      <span class="kd">let</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">arguments</span><span class="p">,</span> <span class="nx">value</span> <span class="o">=&gt;</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">test</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1">//[3, 4]</span>
</code></pre></div></div><p>Array.from还可以设置第三个参数，指定this。</p><p><strong>Array.from()转换可迭代对象：</strong>这个用法只需要一个例子，数组去重。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="k">new</span> <span class="nb">Set</span><span class="p">(...</span><span class="nx">arguments</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">s</span> <span class="o">=</span> <span class="nx">test</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">])</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span> <span class="c1">// [1,"2",3]</span>
</code></pre></div></div><h4 id="给数组添加新方法">给数组添加新方法</h4><p><strong>ES6给数组添加了几个新方法：find()、findIndex()、fill()、copyWithin()。</strong></p><p>1、find()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">find</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">))</span> <span class="c1">// 1</span>
</code></pre></div></div><p>2、findIndex()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="dl">"</span><span class="s2">2</span><span class="dl">"</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">findIndex</span><span class="p">(</span><span class="nx">n</span> <span class="o">=&gt;</span> <span class="k">typeof</span> <span class="nx">n</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">))</span> <span class="c1">// 0</span>
</code></pre></div></div><p>3、fill()：用新元素替换掉数组内的元素，可以指定替换下标范围。</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">arr</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="nx">value</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
</code></pre></div></div><p>测试一下</p><div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span> <span class="c1">// [4, 4, 4] 不指定开始和结束，全部替换</span>
    
    <span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr1</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// [1, 4, 4] 指定开始位置，从开始位置全部替换</span>
    
    <span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr2</span><span class="p">.</span><span class="nx">fill</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// [4, 4, 3] 指定开始和结束位置，替换当前范围的元素</span>
</code></pre></div></div><p>4、copyWithin()：选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="nx">arr</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="nx">target</span><span class="p">,</span> <span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">)</span>
</code></pre></div></div><p>测试一下</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">const</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2</span>
    
    <span class="kd">const</span> <span class="nx">arr1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr1</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="c1">// [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3</span>
    
    <span class="kd">const</span> <span class="nx">arr2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">arr2</span><span class="p">.</span><span class="nx">copyWithin</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="c1">// [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2</span>
</code></pre></div></div><h3 id="总结-2">总结</h3><p>以上内容是通过精读《深入理解ES6》一书和个别大佬文章总结，进行再次汇总，可能有点粗制滥造，但也是对自己所学进行一定的总结，收货颇多，又重新认识了一下ES6，very interesting!</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="http://localhost:4000" target="_blank">Tffeb</a></li><li>本文链接：<a href="http://localhost:4000/2019/12/21/restudy-ES6/" target="_blank">http://localhost:4000/2019/12/21/restudy-ES6/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2019/12/21/restudy-ES6/', clientID: '4ead3b8e3beace354e7b', clientSecret: '6ac6ef4706983c54f356d5f5d7f64f28b69de9a5', repo: 'tffeb.github.io', owner: 'Tffeb', admin: ['Tffeb'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h3>搜索</h3><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'http://localhost:4000/assets/search_data.json', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 12, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">内容目录</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2019 <span title="Tffeb">Tffeb</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/Tffeb/tffeb.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="http://localhost:4000/" title="首页" target="">首页</a></li><li> <a href="http://localhost:4000/categories/" title="分类" target="">分类</a></li><li> <a href="http://localhost:4000/sparetime/" title="业余" target="">业余</a></li><li> <a href="http://localhost:4000/drop/" title="点滴" target="">点滴</a></li><li> <a href="http://localhost:4000/about/" title="关于" target="">关于</a></li><li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2019-10-07 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/vendor/share.js/dist/js/share.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/Tffeb/tffeb.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-179953860-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
