

[
  
  
    {
      "title"    : "页面没有找到",
      "url"      : "http://localhost:4000/404.html",
      "keywords" : "404"
    } ,
  
  
  
    {
      "title"    : "About",
      "url"      : "http://localhost:4000/about/",
      "keywords" : "关于, Tffeb"
    } ,
  
  
  
    {
      "title"    : "归档",
      "url"      : "http://localhost:4000/archives/",
      "keywords" : "归档"
    } ,
  
  
  
    {
      "title"    : "Categories",
      "url"      : "http://localhost:4000/categories/",
      "keywords" : "分类"
    } ,
  
  
  
    {
      "title"    : "点滴",
      "url"      : "http://localhost:4000/drop/",
      "keywords" : "生活, 自我, 行外"
    } ,
  
  
  
  
  
    {
      "title"    : "Open Source Projects",
      "url"      : "http://localhost:4000/open-source/",
      "keywords" : "开源,open-source,GitHub,开源项目"
    } ,
  
  
  
  
  
    {
      "title"    : "业余",
      "url"      : "http://localhost:4000/sparetime/",
      "keywords" : "百科, 洞察, 发现, 收获"
    } ,
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
    {
      "title"    : "算法知识整理",
      "category" : "数据结构与算法",
      "content": "基于学习 javascript 数据结构与算法一书的算法知识整理 斐波那契数列 原理：从第三项开始，每一项等于前两项的和 function fibonac(num) { let fibonacci = [1, 2] for (let i = 1; i &lt; fibonacci.length; i++) {  fibonacci.push(fibonacci[i] + fibonacci[i - 1])  if (num &gt; 2 &amp;&amp; i === num) {  return fibonacci[i - 1]  } else if (num === 1) {  return 1  } else if (num === 2) {  return 2  } } } 栈及其各个方法的封装(使用 es6 语法) class Stack { constructor() {  this.arr = [] } push = element =&gt; {  return this.arr.push(element) } pop = () =&gt; {  return this.arr.pop() } peek = () =&gt; {  return this.arr[this.arr.length - 1] } isEmpty = () =&gt; {  return this.arr.length === 0 } size = () =&gt; {  return this.arr.length } clear = () =&gt; {  return (this.arr = []) } } 将一个值转为进制数 decNumber 为值 base 为进制类型,比如 2,8,16 const baseConverter = (decNumber, base) =&gt; { let remStack = new Stack(),  rem,  baseString = '',  digits = '0123456789ABCDEF' while (decNumber &gt; 0) {  rem = Math.floor(decNumber % base)  remStack.push(rem)  decNumber = Math.floor(decNumber / base) } while (!remStack.isEmpty()) {  baseString += digits[remStack.pop()] } return baseString } 队列 class Queue { constructor() {  this.arr = [] } enqueue = element =&gt; {  return this.arr.push(element) } dequeue = () =&gt; {  return this.arr.shift() } front = () =&gt; {  return this.arr[0] } isEmpty = () =&gt; {  return this.arr.length === 0 } size = () =&gt; {  return this.arr.length } } 优先队列 class QueueElement { constructor(element, priority) {  this.element = element  this.priority = priority } } const items = [] class PriorityQueue { enqueue = (element, priority) =&gt; {  let queueElement = new QueueElement(element, priority)  if (!items.length) {  items.push(queueElement)  } else {  let added = false  for (const i in items) {  if (queueElement.priority &lt; items[i].priority) {   items.splice(i, 0, queueElement)   added = true   break  }  }  if (!added) {  items.push(queueElement)  }  }  return items } } 击鼓传花游戏 const hotPotato = (nameList, num) =&gt; { const queue = new Queue() for (const i in nameList) {  queue.enqueue(nameList[i]) } console.log(queue.size()) let eliminated = '' while (queue.size() &gt; 1) {  for (let i = 0; i &lt; num; i++) {  queue.enqueue(queue.dequeue())  }  eliminated = queue.dequeue()  console.log(eliminated + '在击鼓传花游戏中被淘汰。') } return queue.dequeue() } 单链表 function LinkedList() { var Node = function(element) {  this.element = element  this.next = null } var length = 0 var head = null // 尾部添加一个元素 LinkedList.prototype.append = function(element) {  var node = new Node(element),  current  if (head === null) {  //列表中第一个节点  head = node  } else {  current = head  //循环列表，直到找到最后一项  while (current.next) {  current = current.next  }  //找到最后一项，将其next赋为node，建立连接  current.next = node  }  length++ //更新列表的长度 } // 移除某个元素 LinkedList.prototype.removeAt = function(position) {  //检查越界值  if (position &gt; -1 &amp;&amp; position &lt; length) {  // {1}  var current = head, // {2}  previous, // {3}  index = 0 // {4}  //移除第一项  if (position === 0) {  // {5}  head = current.next  } else {  while (index++ &lt; position) {   // {6}   previous = current // {7}   current = current.next // {8}  }  //将previous与current的下一项链接起来:跳过current，从而移除它  previous.next = current.next // {9}  }  length-- // {10}  return current.element  } else {  return null // {11}  } } // 插入元素 LinkedList.prototype.insert = function(position, element) {  //检查越界值  if (position &gt;= 0 &amp;&amp; position &lt;= length) {  //{1}  var node = new Node(element),  current = head,  previous,  index = 0  if (position === 0) {  //在第一个位置添加  node.next = current  head = node  } else {  while (index++ &lt; position) {   previous = current   current = current.next  }  node.next = current  previous.next = node  }  length++ //更新列表的长度  return true  } else {  return false //{6}  } } // toString() LinkedList.prototype.toString = function() {  var current = head,  string = ''  while (current) {  string = current.element  current = current.next  }  return string //{6} } // get获取某个位置的数据 LinkedList.prototype.get = function(position) {  // 越界判断  if (position &gt;= 0 || position &lt; length) {  var current = head  // head.next = current  var index = 0  while (index++ &lt; position) {  current = current.next  }  return current.element  } } // indexOf() LinkedList.prototype.indexOf = function(element) {  var current = head, //{1}  index = -1  while (current) {  //{2}  if (element === current.element) {  return index //{3}  }  index++ //{4}  current = current.next //{5}  }  return -1 } // 更新某个位置的数据 LinkedList.prototype.update = function(newElement, position) {  if (position &gt;= 0 || position &lt; length) {  var current = head  var index = 0  while (index++ &lt; position) {  current = current.next  }  current.element = newElement  // 修改成功标识  return true  } } // 删除某个数据 LinkedList.prototype.remove = function(element) {  var position = this.indexOf(element)  return this.removeAt(position) } } ",
      "url"      : "http://localhost:4000/2019/08/10/js-about-algorithm/",
      "keywords" : "数据结构与算法, Javascript"
    } ,
  
    {
      "title"    : "mongoDB的配置及启动",
      "category" : "Mongodb",
      "content": "mongodb的使用 配置环境变量，打开终端，输入“open -e .bash_profile” (可以手动输入) 命令行设置环境变量 echo 'export PATH=/usr/local/mongodb/bin:$PATH'&gt;&gt;~/.bash_profile 启动 source ~/.bash_profile(先使配置生效) 停止 mongo &gt;use admin &gt;db.shutdownServer() ",
      "url"      : "http://localhost:4000/2019/08/12/mongodb/",
      "keywords" : "Mongodb"
    } ,
  
    {
      "title"    : "react prop-types的使用",
      "category" : "React",
      "content": "  首先需要通过在终端npm install prop-types或yarn add prop-types安装一个叫prop-types的第三方包   然后通过下面的写法对某一个组件中的变量进行类型检测： componentname.propTypes = {  name1:'变量类型',  name2:'变量类型' } 例如： (有意写错，让其检测) import React from 'react' import PropTypes from 'prop-types'; class Son extends React.Component{ render(){  return (&lt;div style={  { padding:30   }}&gt;     {this.props.number}     &lt;br/&gt;     {this.props.array}     &lt;br/&gt;     {this.props.boolean.toString()}    &lt;/div&gt;)    } } Son.propTypes = {  number:PropTypes.number,  array:PropTypes.array,  boolean:PropTypes.bool } class Father extends React.Component{  render(){  return (&lt;Son    number = {'1'}    array = {'[1,2,3]'}    boolean = {'true'}     /&gt;)    } } propTypes能用来检测全部数据类型的变量，包括基本类型的的字符串，布尔值，数字，以及引用类型的对象，数组，函数，甚至还有ES6新增的符号类型 Son.propTypes = { optionalArray: PropTypes.array,//检测数组类型 optionalBool: PropTypes.bool,//检测布尔类型 optionalFunc: PropTypes.func,//检测函数（Function类型） optionalNumber: PropTypes.number,//检测数字 optionalObject: PropTypes.object,//检测对象 optionalString: PropTypes.string,//检测字符串 optionalSymbol: PropTypes.symbol,//ES6新增的symbol类型 } 【注意】下面这些是从官方英文文档里引用过来的，你大概能够注意到，五种基本类型中的不确定和空并不在此列，propTypes类型检测的缺憾之一是，对于不确定的和无效的值，它无法捕捉错误 把上述实例中的父组件传递给子组件修改一下，改成： class Father extends React.Component{  render(){  return (&lt;Son   number = {null}   array = {null}   boolean = {null}    /&gt;)   } } 结果是输出台不报任何错误，（当然你改成未定义也是同样效果）。 通过oneOfType实现多选择检测-可规定多个检测通过的数据类型 PropTypes里的oneOfType方法可以做到这一点，oneOfType方法接收参数的是一个数组，数组元素是你希望检测通过的数据类型。 import React from 'react' import PropTypes from 'prop-types'; class Son extends React.Component{ render(){ return (&lt;div style ={  {padding:30  }}&gt; {this.props.number} &lt;/div&gt;) } } Son.propTypes = { number:PropTypes.oneOfType( [PropTypes.string,PropTypes.number] ) } class Father extends React.Component{ render(){ //分别渲染数字的11和字符串的11 return (&lt;div&gt; &lt;Son number = {'字符串11'}/&gt; &lt;Son number = {11}/&gt; &lt;/div&gt;) } } 这时候，因为在类型检测中，号码属性的规定类型包括字符串和数字两种，所以此时控制台无报错,当然，如果你改为number = {数组或其他类型的变量}，那么这时就会报错了 通过oneOf实现多选择检测-可规定多个检测通过的变量的值 Son.propTypes = {  number:PropTypes.oneOf(   [12,13]  ) } 此时会报错 arrayOf，objectOf实现多重嵌套检测 如果我们检测的是基本类型的变量，那么这自然是很简单的，但当我们要检测的是一个引用类型的变量呢？当我们除了检测这个变量是否符合规定的引用类型外（对象/阵列），还想要进一步检测对象中的属性变量或阵列中数组元素的数据类型时，单靠上面的方法已经不能满足要求了。这时候就要用到PropTypes的arrayOf，objectOf方法。 arrayOf接收一个参数，这个参数是规定的数组元素的数据类型.objectOf接收的参数则是属性的数据类型 对上述例子做修改： import React from 'react' import PropTypes from 'prop-types'; class Son extends React.Component{  render(){  return (&lt;div style ={  {padding:30  }}&gt;    {this.props.array}   &lt;/div&gt;)  } } Son.propTypes = { array:PropTypes.arrayOf(PropTypes.number) } class Father extends React.Component{  render(){  return (&lt;div&gt;   &lt;Son array = {[1,2,3,4]}/&gt;   &lt;/div&gt;) } } 正常渲染，然后我们把&lt;Son array = {[1,2,3,4]} /&gt; 改为 &lt;Son array = {['1'，'2'，'3'，'4']} /&gt; ，报错 【注意】虽然报错但是这并不会影响程序的正常运行（譬如上面我们看到渲染仍然是正常的），因为本质上说类型检测报的是非致命性错误的警告而不是致命性错误的错误（区别在于是否影响了正常运行）。对objectOf也是同样的做法 objectOf有一个缺陷,就是它内部的属性的数据类型被强行规定为一种，但通常一个对象里应该是有多种不同类型的属性了，那么这时候objectOf就不符合要求了，我们应该使用形状方法，其用法： PropTypes.shape({ 属性1：类型1， 属性2：类型2， //... }) 举个栗子 import React from 'react' import PropTypes from 'prop-types'; class Son extends React.Component{ render(){  return (&lt;div style={  {padding:30  }}&gt;    {'我的名字叫' + this.props.object.name}    &lt;br/&gt;    {'我的年龄是' + this.props.object.age}   &lt;/div&gt;)   } } Son.propTypes = { object:PropTypes.shape({ name:PropTypes.string, age:PropTypes.number  }) } class Father extends React.Component{  render(){  return (&lt;div&gt;    &lt;Son object={  {name:'彭湖湾',age:20  }}/&gt;   &lt;/div&gt;) } } 无报错，把 &lt;Son object={  {name:'彭湖湾',age:20  }} /&gt; 改成 &lt;Son object={  {name:'彭湖湾',age:'20'  }} /&gt; ，然后就能报错了 通过isRequired检测道具中某个必要的属性（如果该属性不存在就报错） 我们在对某个变量进行类型检测时，我们不仅要求它符合预期的类型，同时也要求它是必须写入的，这时候就要用到isRequired。 Son.propTypes = {   number:PropTypes.number } 这段代码的作用是当你中写入号码属性且号码属性类型错误时给予报错提示，可如果你压根就没有写入号码属性呢？没错，什么错误都不会报。这就是使用isRequired的必要性  【注意】上述的写法是数量：PropTypes.number.isRequired，这要求数是数字类型，但如果你不想控制数的类型而仅仅是想控制它的必要性呢？难道写成号：isRequired或number：PropTypes.isRequired？ 这个时候PropTypes.any就登场啦！它代表了该变量可取任何一种数据类型，所以你可以写成这样–number：PropTypes.any.isRequired** 应对更复杂的类型检测 - 将PropTypes的属性值写成函数 Son.propTypes = {  prop:function(props,propName,componentName){   if(/*判断条件*/){   return new Error(/*错误的参数*/)  }  } } 在属性prop的类型检测中，属性值是一个函数，在这里props是包含prop的props对象，propName是prop的属性名，componentName是props所在的组件名称，函数的返回值是一个Error对象 import React from 'react' import PropTypes from 'prop-types'; class Son extends React.Component{  render(){   return (&lt;div style={  {padding:30  }}&gt;     {this.props.email}    &lt;/div&gt;)    } } Son.propTypes = { email:function(props,propName,componentName){   if(!/^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+(.[a-zA-Z0-9_-])+/.test(props[propName])){    return new Error('组件' + componentName+ '里的属性' + propName + '不符合邮箱的格式');     }    } } class Father extends React.Component{  render(){   return (&lt;div&gt;     &lt;Son email = {2314838004}/&gt;    &lt;/div&gt;)    } } ES7下类型检测的新写法： class Son extends React.Component{ static propTypes = {  //..类型检测 } render(){ return (/* 渲染*/) } } props-types的独立与react.PropTypes的弃用 在上面我是利用props-types这个独立的第三方库来进行类型检测的，但在不久前（react V15.5以前），它使用的是react内置的类型检测，而不是第三方库（也就是说我们现在的prop-types是当初以react内置的PropTypes对象为基础分离出来的） 所以说在你也可以这样进行类型检测，虽然并不推荐（为了保持向下兼容这在最新版本的react上仍然是可用的） Son.propTypes = {  number:React.PropTypes.number } ",
      "url"      : "http://localhost:4000/2019/08/14/react-proptypes/",
      "keywords" : "React"
    } ,
  
    {
      "title"    : "在react中使用装饰器和Mobx如何去配置",
      "category" : "MobX",
      "content": " 首先构建脚手架项目,（其他文件可删除只留如下目录文件） // 构建脚手架项目指令 create-react-app MobxApp 然后安装mobx, mobx-react // 安装 yarn add mobx mobx-react 重点来了（关于装饰器的配置） 经常遇到的装饰器@符号不被识别，怎么解决呢？ 首先安装 customize-cra react-app-rewired @babel/plugin-proposal-decorators // 安装上面依赖 yarn add customize-cra react-app-rewired @babel/plugin-proposal-decorators --dev 然后在package.json中添加配置 babel: {  presets: [  react-app  ],  plugins: [  [  transform-decorators-legacy  ]  ] } 再更改package.json中的”scripts”部分 scripts: {  start: react-app-rewired start,  build: react-app-rewired build,  test: react-app-rewired test,  eject: react-app-rewired eject }, 然后在项目根目录新建config-overrides.js文件，再添加以下配置 const { override, addDecoratorsLegacy } = require('customize-cra'); module.exports = override(  addDecoratorsLegacy() ) 这个时候我们便可以开始使用我们的mobx和装饰器了 在index.js里可以是初始化状态，具体如下： import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; ReactDOM.render(&lt;App /&gt;, document.getElementById('root')); 在App.js里我们使用mobx和装饰器 import React, { Component } from 'react'; import { observer } from 'mobx-react' import { observable } from 'mobx' @observer class App extends Component { @observable count = 1 render() {  return (  &lt;div className=App &gt;  {this.count}  &lt;/div&gt;  ); } } export default App; 最后，我们的项目便可以跑起来了,yarn start正常运行项目 总结 MobX通过透明的函数响应式编程，使得状态管理变得简单可扩展，MobX很强大且好用，在react中使用个人认为比redux轻便多了。 ",
      "url"      : "http://localhost:4000/2019/08/29/mobx/",
      "keywords" : "MobX"
    } ,
  
    {
      "title"    : "Git Command Line",
      "category" : "Git",
      "content": "git 关于切换分支操作  git push origin :xn或者git push origin --delete xn(将一个空分支推送到远程即为删除) git checkout -b xn(新建本地为 xn 的分支并切换至 xn 分支) git push origin xn:xn(将本地 xn 分支推送至远程 xn 分支) git 上传项目  git add . (把所有文件添加到暂存区里) git commit -am ‘备注’ (备注项目) git remote add origin 远程仓库地址名称 (添加远程仓库） git push (上传到远程仓库） git 相关指令  git remote set-url origin 设置新的远程仓库地址 或 git remote rm origin 移除远程仓库地址 git status (查看所有文件) rm -rf .git/ (移除 git,移除相关文件) ll (查看列表) git branch —all /-r (查看远程所有的分支) git branch (查看本地分支) git branch -a (查看所有分支) git branch 分支名 （新建分支) git checkout master (切换基础分支) git fetch (获取所有分支) git fetch origin 分支名（下拉远程的分支文件） git pull (下拉远程分支文件并合并) git diff (比较所有的文件的修改) git clone [url] （克隆远程项目） git checkout —set-upstream origin beta_lbs (切换到远程的分支) 或者 git push --set-upstream origin beta_lbs （直接推送到远程) master 分支的代码领先自己的分支,git 如何把 master 分支代码合并到自己的分支 1.切换 master 分支  git checkout master 2.使用 git pull 把领先的主分支代码 pull 下来 git pull 3.切换到自己的分支 git checkout xxx(自己的分支) 4.把主分支的代码 merge 到自己的分支 git merge master 5.git push 推上去 ok 完成,现在 你自己分支的代码就和主分支的代码一样了 git push 最简单的办法如下： 1.git fetch origin beta (下拉远程主分支) 2.git merge origin/beta (合并主分支) git 遇到的问题 Git冲突：commit your changes or stash them before you can merge. 解决办法  git stash git pull git stash pop 冲突没有解决可回退  git reset --merge ",
      "url"      : "http://localhost:4000/2019/09/02/git-code/",
      "keywords" : "Git"
    } ,
  
    {
      "title"    : "moment-API用法",
      "category" : "API",
      "content": "前言 时间处理几乎在每个项目中都会被使用到，我们需要将时间转为各种格式，以方便使用。moment 这个API就解决就可以有效解决时间处理问题。 接下来，咱们开始进入了解moment。 在模块化开发中使用    npm install moment –save  yarn add moment   时间处理集锦 Tip: 当前时间为2019-09-11,以这个时间为基础moment()就是当前时间 moment()  // _d: Wed Sep 11 2019 16:15:08 GMT+0800 (中国标准时间) {}  // _isAMomentObject: true  // _isUTC: false  // _isValid: true  // _locale: j {_calendar: {…}, _longDateFormat: {…}, _invalidDate: Invalid date, _dayOfMonthOrdinalParse: /  d{1,2}(  u65e5|  u6708|  u5468)/, ordinal: ƒ, …}  // _pf: {empty: false, unusedTokens: Array(0), unusedInput: Array(0), overflow: -2, charsLeftOver: 0, …}  // _z: null  // __proto__: Object 初始化日期/时间 // 初始化日期 moment().format('YYYY-MM-DD'); // 2019-09-11 // 初始化时间 moment().format('YYYY-MM-DD HH:mm:ss'); // 2019-09-11 16:19:21 格式化日期/时间 // value 可为时间戳或时间格式 'v' | '2019/09/11' | moment() | moment().valueOf() 也就是时间戳 // 格式化日期 moment(value).format('YYYY-MM-DD'); // 格式化时间 moment(value).format('YYYY-MM-DD HH:mm:ss');  加/减 ，处理的日期时间格式 // 在某个时间的基础上添加一个时间 moment().add(2,'day').format('YYYY-MM-DD') // 2019-09-13 moment().add(2,'month').format('YYYY-MM-DD') // 2019-11-11 // subtract(90,'day') 和 subtract('days', 90) 一样 // 截取出90天前的日期 moment().subtract(90,'day').format('YYYY-MM-DD') // 2019-06-13 // 截取出90天前的起始时间 moment().subtract(90,'day').startOf('day').format('YYYY-MM-DD HH:mm:ss') //2019-06-13 00:00:00 // 截取出90天前的末尾时间 moment().subtract(90,'day').endOf('day').format('YYYY-MM-DD HH:mm:ss') //2019-06-13 23:59:59 // 截取 3月前的日期 moment().subtract(3, 'month').startOf('month').format('YYYY-MM-DD HH:mm:ss') // 2019-06-01 00:00:00 moment().subtract('days', 3).format('YYYY-MM-DD') // 2019-06-01 获取星期几 moment().day() // 3 // 注意 如果星期天那就是0 moment('2019-09-15').day() // 0 获取时间戳精确毫秒或秒 //精确毫秒 moment('2019-09-11').valueOf() // 1568131200000 //精确秒 moment().unix() // 1625131400 获取时间差 // 注意：计算时间差时，可以以 “years”、“days”、“hours”、“minutes” 以及 seconds 为单位输出！ moment('2019-09-12').diff(moment('2019-09-11'), 'minutes') // 1440 moment('2019-09-12').diff(moment('2019-09-13'), 'hours') // -24 判断一个日期是否在两个日期之间 语法：moment().isBetween(moment-like, moment-like, String, String); moment('2019-09-12').isBetween('2019-09-11', '2019-09-13') // true moment('2019-09-11').isBetween('2019-09-11', '2019-09-13') // false moment('2019-09-11').isBetween('2019-09-11', '2019-09-13',null,'[)') // true moment('2019-09-11').isBetween('2019-09-11', '2019-09-13',null,'()') // false 实战 如何将后端的接口返回的时间戳转化为自定义时间格式  const data = res.data.time //假设是后端的时间戳数据  Date.prototype.toLocaleString = function() {   console.log(this.getYear() + '年' + (this.getMonth() + 1) + '月' + this.getDate() + '日')  }  let date = new Date(data)  date.toLocaleString() 时间戳转格式化时间 /** * @param &lt;Number&gt; params 13位时间戳 * @return &lt;String&gt; type yyyy/mm/dd，yyyy/mm/dd hh:MM:ss，yyyy-mm-dd，yyyy-mm-dd hh:MM:ss */ const timestampFromat = (params, type) =&gt; {  if (params == 0 || params == undefined) {  return '无';  }  const date = new Date(params);  let yyyy = date.getFullYear();  let mm = date.getMonth() + 1;  mm = mm &lt; 10 ? ('0' + mm) : mm;  let dd = date.getDate();  dd = dd &lt; 10 ? ('0' + dd) : dd;  let hh = date.getHours();  hh = hh &lt; 10 ? ('0' + hh) : hh;  let MM = date.getMinutes();  MM = MM &lt; 10 ? ('0' + MM) : MM;  let ss = date.getSeconds();  ss = ss &lt; 10 ? ('0' + ss) : ss;  switch(type)  {  case 'yyyy.mm.dd':   return yyyy + '.' + mm + '.' + dd;   break;  case 'yyyy/mm/dd':   return yyyy + '/' + mm + '/' + dd;   break;  case 'yyyy-mm-dd':   return yyyy + '-' + mm + '-' + dd;   break;  case 'yyyy-mm':   return yyyy + '-' + mm;   break;  case 'yyyy/mm/dd hh:MM:ss':   return yyyy + '/' + mm + '/' + dd + ' ' + hh + ':' + MM + ':' + ss;   break;  case 'yyyy-mm-dd hh:MM:ss':   return yyyy + '-' + mm + '-' + dd + ' ' + hh + ':' + MM + ':' + ss;   break;  case 'yyyy-mm-dd hh:MM':   return yyyy + '-' + mm + '-' + dd + ' ' + hh + ':' + MM;   break;  case 'hh:MM:ss':   return hh + ':' + MM + ':' + ss;   break;  default:   return '请输入正确的type类型';  } } public static momentDate(num: any, type: string = 'date_time'): string {  if (num) {  if (Object.prototype.toString.call(num) === '[object Date]') {  num = num.getTime()  }  switch (type) {  case 'date':   return moment(parseInt(num, 10)).format('YYYY-MM-DD')  case 'date_h':   return moment(parseInt(num, 10)).format('YYYY/MM/DD')  case 'date_time':   return moment(parseInt(num, 10)).format('YYYY-MM-DD HH:mm:ss')  case 'data_h_time':   return moment(parseInt(num, 10)).format('YYYY/MM/DD HH:mm:ss')  case 'data_h_time_h':   return moment(parseInt(num, 10)).format('YYYY/MM/DD HH:mm')  case 'time':   return moment(parseInt(num, 10)).format('HH:mm:ss')  case 'time_h':   return moment(parseInt(num, 10)).format('HH:mm')  default:   return moment(parseInt(num, 10)).format('YYYY-MM-DD HH:mm:ss')  }  } else {  return ''  } } ",
      "url"      : "http://localhost:4000/2019/09/11/js-moment/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "yarn的安装与使用",
      "category" : "Yarn",
      "content": "yarn的安装  npm install -g yarn（使用Node)  npm install yarn@latest -g（升级到最新版本） /usr/bin/ruby -e $(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install) (homebrew的安装) brew install yarn (使用homebrew安装yarn) 查询当前配置的镜像  yarn config get registry 设置成淘宝镜像  yarn config set registry http://registry.npm.taobao.org/ yarn和npm的使用  初始化包 npm init yarn init 安装包 npm install xxx --save yarn add xxx 移除包 npm uninstall xxx yarn remove xxx 更新包 npm update xxx yarn upgrade xxx 5.安装开发依赖的包  npm install xxx --save-dev yarn add xxx --dev 全局安装 npm install -g xxx yarn global add xxx 设置下载镜像的地址 npm config set registry url yarn config set registry url 安装所有依赖 npm install yarn install 执行包 npm run yarn run 如果中途yarn装依赖时报错 error Incorrect integrity when fetching from the cache info Visit https://yarnpkg.com/en/docs/cli/add for documentation about this command. 使用 yarn cache clean 解决（清除缓存） ",
      "url"      : "http://localhost:4000/2019/09/11/yarn-command/",
      "keywords" : "Yarn"
    } ,
  
    {
      "title"    : "关于http的理解",
      "category" : "HTTP",
      "content": " 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法 http协议的作用及特点 HTTP是一个客户端和服务器端请求和应答的标准,客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理。在用户代理和源服务器中间可能存在多个中间层，比如代理，网关，或者隧道（tunnels） 1.基于请求/响应模型的协议。请求和响应必须成对，先有请求后有响应。 2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST、DELETE、PUT、TRACE、PATCH、CONNECT、OPTIONS。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。 3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。 4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 协议的组成 http请求包括:请求行、请求头、请求体 http响应包括:响应行、响应头、响应体 请求方法 get请求 将请求参数追加在url后面，不安全 url长度限制get请求方式数据的大小 没有请求体 post请求 请求参数在请求体处，较安全。 请求数据大小没有限制 HEAD请求 HEAD跟GET相似，不过服务端接收到HEAD请求时只返回响应头，不发送响应内容。所以，如果只需要查看某个页面的状态时，用HEAD更高效，因为省去了传输页面内容的时间。 DELETE请求 删除某一个资源。 OPTIONS请求 用于获取当前URL所支持的方法。若请求成功，会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。 PUT请求 把一个资源存放在指定的位置上。 本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。 TRACE请求 回显服务器收到的请求，主要用于测试或诊断。 CONNECT请求 CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。 状态码  1xx：指示信息，表示请求已接收，继续处理  2xx：成功，表示请求已被成功接受，处理。 200 OK：客户端请求成功 204 No Content：无内容。服务器成功处理，但未返回内容。一般用在只是客户端向服务器发送信息，而服务器不用向客户端返回什么信息的情况。不会刷新页面。  206 Partial Content：服务器已经完成了部分GET请求（客户端进行了范围请求）。响应报文中包含Content-Range指定范围的实体内容 3xx：重定向 301 Moved Permanently：永久重定向，表示请求的资源已经永久的搬到了其他位置。 302 Found：临时重定向，表示请求的资源临时搬到了其他位置 303 See Other：临时重定向，应使用GET定向获取请求资源。303功能与302一样，区别只是303明确客户端应该使用GET访问 307 Temporary Redirect：临时重定向，和302有着相同含义。POST不会变成GET  304 Not Modified：表示客户端发送附带条件的请求（GET方法请求报文中的IF…）时，条件不满足。返回304时，不包含任何响应主体。虽然304被划分在3XX，但和重定向一毛钱关系都没有 4xx：客户端错误 400 Bad Request：客户端请求有语法错误，服务器无法理解。 401 Unauthorized：请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用。 403 Forbidden：服务器收到请求，但是拒绝提供服务 404 Not Found：请求资源不存在。比如，输入了错误的url  415 Unsupported media type：不支持的媒体类型 5xx：服务器端错误，服务器未能实现合法的请求。 500 Internal Server Error：服务器发生不可预期的错误。 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能恢复正常 Content-Type(请求报文头属性)    Content-Type  解释     text/html  html格式    text/plain  纯文本格式    text/css  css格式    text/javascript  js格式    image/gif  gif图片格式    image/*  其他图片格式    application/x-www-form-urlencoded  POST专用：普通的表单提交默认是通过这种方式。form表单数据被编码为key/value格式发送到服务器。    application/json  POST专用：用来告诉服务端消息主体是序列化后的 JSON 字符串    text/xml  POST专用：发送xml数据    multipart/form-data  POST专用：使用表单上传文件   TCP三次握手  进行三次握手的原因为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 图解  第一次握手         建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；   第二次握手         服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；   第三次握手        客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 =========================== 四次挥手 进行四次挥手的原因TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。 图解  第一次分手        主机1（可以使客户端，也可以是服务器端），设置Sequence Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；   第二次分手        主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；   第三次分手        主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；   第四次分手        主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。 ",
      "url"      : "http://localhost:4000/2019/12/10/about-http/",
      "keywords" : "HTTP"
    } ,
  
    {
      "title"    : "重学ES6（跟着《深入理解ES6》学习）",
      "category" : "ES6",
      "content": " 主流浏览器使用的是 es5、es6(es2015),ES6目前是新的标准, es7(2016), es8(2017), es9(2018), es10(2019) 一、了解var、let、const关键字的特性和用法  var 在javascript中，我们通常说的作用域是函数作用域，使用var声明的变量，无论是在代码的哪个地方声明的，都会提升到全局作用域的顶部，这种行为叫做变量提升 也就是说，如果在函数内部声明的变量，都会被提升到该函数开头，而在全局声明的变量，就会提升到全局作用域的顶部。 // example: (function() { console.log(a); //undefined if(false) {  var a = 1; } console.log(a) //undefined })() 实际执行是，上面代码中的变量a会提升到函数顶部声明，即使if语句的条件是false,也一样不影响a变量提升 (function(){ var a; console.log(a); //undefined if(false) {  var a = 1; } console.log(a) //undefined })() 在函数嵌套函数的场景下，变量只会提升到最近的一个函数顶部，而不会提升到外部函数 // b提升到函数a顶部，但不会提升到函数a外边. (function(){ function a() {  if(false) {  var b = 2;  } } console.log(b); // b is not undefined })() 如果a没有声明，那么就会报错，没有声明和声明后没有赋值是不一样的，这一点要区分。  let let和const都能够声明块级作用域，用法和var类似的，let的特点是不会变量提升，而是被锁在当前块中。 //example function test() { if(true) {  console.log(a);  let a = 1; } } test(); // a is not undefined function test() { if(true) {  let a = 1; } console.log(a) } test() // a is not defined  const 声明常量，一旦声明，不可更改，而且常量必须初始化赋值。 const type = ACTION type = 1; console.log(type) // type is read-only const type = ACTION let type = 1 console.log(type) // duplicate declaration type const虽然是常量，不允许修改默认赋值，但如果定义的是对象Object,那么可以修改对象内部的属性值包括新增删除键值对也是可以的。 const type = { a:1 } type.a = 2 //没有直接修改type的值 console.log(type) // {a:2} type.b = 3 //拓展Object也没问题 console.log(type) //{a:2,b:3} delete type.b = 3 //删除整个键值对也可 console.log(type) // {a:2} //如果重新定义数据结构，常量的内存地址值发生改变，这个是不可行的 type = {}; //assignment to constant variable. type = []; //assignment to constant variable.  const和let的异同点 相同点: const和let都是在当前块内有效，执行到块外会被销毁，也不存在变量提升(TDZ),不能重复声明。 不同点：const不能再赋值，let声明的变量可以重复赋值 临时(暂时性)死区(TDZ) 临时死区的意思是在当前作用域的块内，在声明变量前的区域叫做临时死区。 if(true) { //这块区域是TDZ let a = 1 }  块级作用域的使用场景 在for循环中使用var声明的循环变量，会跳出循环体污染当前的函数  for(var i = 0; i &lt; 5; i++) {  setTimeout(() =&gt; {  console.log(i) //5, 5, 5, 5, 5  }, 0)  }  console.log(i) //5 i跳出循环体污染外部函数  //将var改成let之后  for(let i = 0; i &lt; 5; i++) {  setTimeout(() =&gt; {  console.log(i) // 0,1,2,3,4  }, 0)  }  console.log(i)//i is not defined i无法污染外部函数  在全局作用域声明 如果在全局作用域使用let或者const声明，当声明的变量本身就是全局属性，比如closed,只会覆盖该全局变量，而不会替换它， window.closed = false let closed = true console.log(closed) // true window.closed // false  最佳实践 在实际开发中，我们选择使用var,let还是const,取决于我们的变量是不是需要更新，通常我们希望变量保证不被恶意修改，而使用大量的const,在react中，props传递的对象是不可更改的，所以使用const声明，声明一个对象的时候，也推荐使用const,当你需要修改声明的变量值时，使用let, var能用的场景都可以使用let替代。 二、了解字符串 字符串(String)是js六大原始数据类型之一，其他几个分别是Boolean、Null、Undefined、Number、Symbol（es6新增）。  ES6字符串新增的方法   新增  含义     UTF-16码位  ES6强制使用UTF-16字符串编码    codePointAt()  该方法支持UTF-16，接受编码单元的位置而非字符串位置作为参数，返回与字符串中给定位置对应的码位，即一个整数值。    String.fromCodePoint()  作用与codePointAt相反，检索字符串中某个字符的码位，也可以根据指定的码位生成一个字符。    normalize()  提供Unicode的标准形式，接受一个可选的字符串参数，指明应用某种Unicode标准形式。   字符串中的子串识别 ES6之前 let t = abcdefg if(t.indexOf('cd') &gt; -1) { console.log(2) } // 输出2，因为t字符串中包含cde字符串 ES6新增    新增  含义     includes(str, index)  如果在字符串中检测到指定文本，返回true，否则false。    startsWith(str, index)  如果在字符串起始部分检测到指定文本，返回true，否则返回false。    endsWith(str, index)  如果在字符串的结束部分检测到指定文本，返回true，否则返回false。   // example includes(str, index)  let t = 'abcdefg'  if(t.includes('cde')) {  console.log(2)  }  // 2 // example startsWith(str, index)  let t = 'abcdefg'  if(t.startsWith('ab')) {  console.log(2)  }  //2 // example endsWith(str, index)  let t = 'abcdefg'  if(t.endsWith('fg')) {  console.log(2)  }  //2 如果你只是需要匹配字符串中是否包含某个字符串，那么推荐使用新增的方法，如果需要找到匹配字符串的位置，使用indexOf() repeat(number)方法 该方法接收一个Number类型的数据，返回一个重复N次的新字符串。即使这个字符串是空字符，也你能返回N个空字符的新字符串。 console.log('ba'.repeat(4)) // babababa 模板字面量 以前是单、双引号表示字符串 let a = '123' let b = 321 在ES6，可以使用模板字面量反撇号``,在实际开发中，这是经常都要用到的方法。 let c = `123` 在字符串中使用反撇号，只需要加上转义符即可。 let d = `12  `3` 在多行字符串的使用价值 模板字面量为解决多行字符串的一系列问题提供了一个非常好的机制。 如果不使用模板字面量，实现多行字符串，你可能会使用换行符。 let a = '123  456' 使用模板字面量，就可以非常简单的实现需求。 let a = `123 456 ` 在模板字面量插入变量的方法 我们不再需要使用 + 来向字符串插入变量，而是使用${params}直接插入你需要添加到字符串的位置。 let t = 'haha' let a = `123${t}456` 这种方式也叫作字符串占位符，占位符支持互相嵌套模板字面量。 模板字面量的终极用法 tag是一个方法，方法名称可以任意命名，这种写法被称作标签模板。 function tag(literals,...substitutions) { // literals是数组，第一个位置是,第二个位置是站位符之间的字符串，本例中是sss // substitutions是字符串中模板字面量，可能多个 console.log(literals) // [, sss, , raw: Array(3)] console.log(substitutions) // [4,2] } let a = 4 let t = tag`${a} sss${2}` 总结 本章降到ES6中新增的Unicode方法,如果不需要做国际化处理，基本上用不到，关注新增的字符串匹配的3个方法，以及模板字面量的使用，这两点很常用。 三、函数 在ES5中，我们给函数传参数，然后在函数体内设置默认值，如下面这种方式。 function a(num,callback) { num = num || 6; callback = callback || function(data) {console.log('ES5:',data)} callback(num * num) } a() 在ES6中，我们使用新的默认值写法 function a(num = 6,callback = function(data) {  console.log('ES6',data) }) {  callback(num * num) } a(10,function(data){console.log(data*10)}) ***** 使用es6的默认值写法可以让函数体内的代码更加简洁优雅 默认值对arguments对象的影响 我们先要了解arguments对象是啥？准确来说它是一个类数组对象，它在函数内部，它将当前函数的所有参数都组成了一个类数组对象。 function a(num,b) { console.log(arguments) // {0: 6, 1: 10} console.log(arguments.length) // 2 } a(6,10) 上面的输出结果看起来很正常，那么，如果加上默认值会怎样呢？ function a(num = 1, b = 1) { console.log(arguments) } a() // {} 默认值不能被arguments识别。 a(6,10) // {0: 6, 1: 10} 下面我们看一下修改参数默认值对arguments的影响。 1、在ES5的非严格模式下，一开始输入的参数是1，那么可以获取到arguments[0],修改num = 2之后，arguments[0]也能更新到2 function a(num) { console.log(num === arguments[0]) // true num = 2 // 修改参数默认值 console.log(num === arguments[0]) // true } a(1) 2、在es5严格模式下，arguments就不能在函数内修改默认值后跟随着更新了 use strict; //严格模式  function a(num) {  console.log(num === arguments[0]); // true  num = 2;  console.log(num === arguments[0]); // false  }  a(1); ** 在ES6环境下，默认值对arguments的影响和ES5严格模式是同样的标准。 默认参数表达式 参数不仅可以设置默认值为字符串，数字，数字或者对象，还可以是一个函数 function add() {  return 10 } function a(num = add()) {  console.log(num) } a() // 10 默认参数的临时死区 第一章我们提到let、const什么是变量的TDZ,默认参数既然是参数，那么也同样有临时死区，函数的作用域是独立的，a函数不能共享b函数的作用域参数。 //这是个默认参数临时死区的例子，当初始化a时，b还没有声明，所以第一个参数对b来说就是临时死区。  function add(a = b, b){  console.log(a + b)  }  add(undefined, 2) // b is not define 无命名参数 function add(object) { console.log(object.a + object.b) } let obj = { a:1, b:2 } add(obj) // 3 不定参数的使用 使用…（展开运算符）的参数就是不定参数，它表示一个数组 function add(...arr) {  console.log(a + b) } let a = 1,b = 2 add(a,b) // 3 不定参数的使用限制 必须放在所有参数的末尾，不能用于对象字面量setter中。 // 错误的写法1 function add(...arr,c) {  console.log(a + b) } let a = 1,b = 2,c = 3 add(a,b,c) // 错误的写法2 let obj = {  set add(...arr) { } } ***** ES6中的构造函数Function新增了支持默认参数和不定参数 展开操作符 展开运算符的作用是解构数组，然后将每个数组元素作为函数参数，有了展开运算符，我们操作数组的时候，就可以不再使用apply来指定上下文环境了。 // es5的写法 var arr = [10,20,50,40,30] var a = Math.max.apply(null,arr) console.log(a) // 50 // es6的写法 let arr = [10,20,30,40] let a = Math.max(...arr) console.log(a) // 40 块级函数 严格模式下在es6中，你可以在块级作用域内声明函数，该函数的作用域只限于当前块，不能在块的外部访问。 use strict; if(true) { const a = function() {  } } 非严格模式即使在ES6中，非严格模式下的块级函数，他的作用域也会被提升到父级函数的顶部。所以大家写代码尽量使用严格模式，避免这些奇葩情况。 箭头函数 const arr = [5,10] const s = arr.reduce((sum,item) =&gt; sum + item) console.log(s) // 15 箭头函数和普通函数的区别 1、箭头函数没有this，函数内部的this来自于父级最近的非箭头函数，并且不能改变this的指向。 2、箭头函数没有super 3、箭头函数没有arguments 4、箭头函数没有new.target绑定。 5、不能使用new 6、没有原型 7、不支持重复的命名参数。 箭头函数的简单理解 1、箭头函数的左边表示输入的参数，右边表示输出的结果。 const s = a =&gt; a  console.log(s(2)) // 2 2、箭头函数中，最重要的this报错将不再成为你每天都担心的bug。 3、箭头函数还可以输出对象。 const action = (type, a) =&gt; ({  type: TYPE,  a  }) 4、支持立即执行函数表达式写法 const test = ((id) =&gt; {  return {  getId() {   console.log(id)  }  }  })(18)  test.getId() // 18 5、箭头函数给数组排序 const arr = [10, 50, 30, 40, 20]  const s = arr.sort((a, b) =&gt; a - b)  console.log(s) // [10,20,30,40,50] 尾调用优化 尾调用是指在函数return的时候用一个新的函数,由于尾调用的实现需要存储到内存中,在一个循环体中，如果存在函数的尾调用，你的内存可能爆满或溢出。  ES6中，引擎会帮你做好尾调用的优化工作，你不需要自己优化，但需要满足下面3个要求： 1、函数不是闭包 2、尾调用是函数最后一条语句 3、尾调用结果作为函数返回 一个满足以上要求的函数如下所示： use strict;  function a() {  return b();  } 下面的都是不满足的写法： //没有return不优化  use strict;  function a() {  b();  }  //不是直接返回函数不优化  use strict;  function a() {  return 1 + b();  }  //尾调用是函数不是最后一条语句不优化  use strict;  function a() {  const s = b();  return s  }  //闭包不优化  use strict;  function a() {  const num = 1  function b() {  return num  }  return b  } 尾调用实际用途——递归函数优化 在ES5时代，我们不推荐使用递归，因为递归会影响性能。 但是有了尾调用优化之后，递归函数的性能有了提升。 //新型尾优化写法  use strict;  function a(n, p = 1) {  if(n &lt;= 1) {  return 1 * p  }  let s = n * p  return a(n - 1, s)  }  //求 1 x 2 x 3的阶乘  let sum = a(3)  console.log(sum) // 6 四、对象 在ES6中，对象分为下面几种叫法  普通对象   特异对象   标准对象   内建对象 对象字面量语法拓展 随便打开一个js文件，对象都无处不在，看一个简单的对象。 {  a: 2  } es6针对对象的语法扩展了一下功能 1、属性初始值简写 // es5 function a(id) { return{  id:id } } // es6 const a = id =&gt; ({ id }) 2、对象方法简写 // ES5  const obj = {  id: 1,  printId: function() {  console.log(this.id)  }  }  // ES6  const obj = {  id: 1,  printId() {  console.log(this.id)  }  } 3、属性名可计算 属性名可以传入变量或者常量，而不只是一个固定的字符串。 const id = 5 const obj = {  [`my-${id}`]:id } console.log(obj['my-5']) // 5 es6对象新增方法 在Object原始对象上新增方法，原则上来说不可取，但是为了解决全世界各地提交的issue,在es6中的全局Object对象上新增了一些方法。 Object.is() 用来解决Javascript中特殊类型 == 或者 === 异常的情况 // example  //实际出现了异常(错误输出)  console.log(NaN === NaN) // false  console.log(+0 === -0) // true  console.log(5 == 5) //true  //我们期望的目标输出(正确输出)  console.log(NaN === NaN) // true  console.log(+0 === -0) // false  console.log(5 == 5) //false 为了解决上面问题，新增了Object.is()来处理2个值的比较。 console.log(Object.is(NaN, NaN)) // true  console.log(Object.is(+0, -0)) // false  console.log(Object.is(5, 5)) //false Object.assign() 也许你已经见过或者使用过这个方法了，那这个新增的方法解决了什么问题呢？ 答：混合（Mixin）。 mixin是一个方法，实现了拷贝一个对象给另外一个对象，返回一个新的对象。 下面是一个mixin方法的实现，这个方法实现的是浅拷贝。将b对象的属性拷贝到了a对象，合并成一个新的对象。 // mixin不只有这一种实现方法 function mixin(receiver,supplier) { Object.keys(supplier).forEach(key =&gt; {  receiver[key] = supplier[key] }) return receiver } let a = {name:'cnm'}; let b = { c:{  d:5 } } console.log(mixin(a,b)) // {name:cnm,c:{d:5}} 写这样一个mixin方法是不是很烦，而且每个项目都得引入这个方法，现在，ES6给我们提供了一个现成的方法Object.assign()来做mixin的事情。 假设要实现上面的mixin方法，你只需要给Object.assign()传入参数即可。 console.log(Object.assign(a, b))// {name:cnm,c:{d:5}} 使用Object.assign()继承 Object.assign 方法只复制源对象中可枚举的属性和对象自身的属性。 看一个实现Component的例子。 //声明一个对象Component  let Component = {}  //给对象添加原型方法  Component.prototype = {  componentWillMount() {},  componentDidMount() {},  render() {console.log('render')}  }  //定义一个新的对象  let MyComponent = {}  //拷贝Component的方法和属性。  Object.assign(MyComponent, Component.prototype)  console.log(MyComponent.render()) // render 在react的reducer中，每次传入新的参数返回新的state，你都可能用到Object.assign()方法。 重复的对象字面量属性 ES5的严格模式下，如果你的对象中出现了key相同的情况，那么就会抛出错误。而在ES6的严格模式下，不会报错，后面的key会覆盖掉前面相同的key。 const state = {  id: 1,  id: 2  }  console.log(state.id) // 2 自有属性枚举顺序 这个概念看起来比较模糊，如果你看了下面的例子，你可能就会明白在说什么了。 const state = {  id: 1,  5: 5,  name: eryue,  3: 3  }  Object.getOwnPropertyNames(state) //[3,5,id,name] 枚举key Object.assign(state, null)  //{3:3,5:5,id:1,name:eryue} 上面的例子的输出结果都有个规律，就是数字提前，按顺序排序，接着是字母排序。而这种行为也是ES6新增的标准。你还可以自己测试一下其他方法是不是也支持枚举自动排序。比如Object.keys(), for in 等。 增强对象原型 如果你想定义一个对象，你会想到很多方法 let a = {} let b = Object.create(a) function C() {} class D {} 那么，ES6是如何在这么强大的对象上面继续增强功能呢？ 1、允许改变对象原型 改变对象原型，是指在对象实例化之后，可以改变对象原型，我们使用Object.setPrototypeOf() 来改变实例化后的对象原型。 let a = {  name() {  return 'eryue'  } } let b = Object.create(a) console.log(b.name()) // true // 使用setPrototypeOf改变b的原型 let c = {  name() {  return 'sb'  } } Object.setPrototypeOf(b,c) console.log(b.name()) // sb 方法的定义 ES6明确了方法的定义 let a = {  // 方法  name() {  return 'eryue';  } } // 函数 function name () {} 总结 本章讲解了对象字面量语法拓展，ES6新增方法，允许重复的对象字面量属性，自有枚举属性排序，增强对象原型，明确了方法的定义。 五、解构语法 解构的分类 1、对象解构 2、数组解构 3、混合解构 4、解构参数 对象解构 let obj = {  a: 1,  b: [1, 2]  }  // 对象解构  const { a, b } = obj  console.log(a, b) //1 [1, 2] 在函数中使用解构赋值 解构是将对象或者数组的元素一个个提取出来，而赋值是给元素赋值，解构赋值的作用就是给对象或者数组的元素赋值。 let props = {  a: 1,  b: 2  }  function test(value) {  console.log(value)  }  test({a=3, b=3} = props) // {a: 1, b: 2} 在调用test()函数的时候，我们给参数设置了默认值3，如果不重新赋值，则打印出3,3，但是进行解构赋值后，将props对象的参数解构赋值给a和b，所以打印结果是{a: 1, b: 2} 下面这个例子定义了a = 3,b = 3两个变量，现在我们想修改这2个变量的值，采用解构赋值的方式可以这样做：定义一个props对象，该对象包含2个属性a和b，然后进行解构赋值，这时就能更新变量a和b的value。 let props = {  a: 1,  b: 2  },  a = 3,  b = 3;  //解构赋值  ({ a, b } = props)  console.log(a, b) // 1, 2 在react的父子组件传递参数过程中，也使用到了解构赋值。 class Parent extends React.Component {  render() {  const {a = 3, b = 3} = this.props  return &lt;h1&gt;{a}-{b}&lt;/h1&gt;  }  }  ReactDOM.render(  &lt;Parent a=1 b=2 /&gt;,  document.getElementById('root')  );  //在浏览器渲染 1-2，默认值是 3-3，但是因为传递了新的props进来，执行了解构赋值之后a和b更新了。 嵌套对象解构 当对象层次较深时，你也可以解构出来。 let obj = {  a: {  b: {   c: 5  }  }  }  const {a: {b}} = obj  console.log(b.c) // 5  数组解构 数组解构比对象解构简单，因为数组只有数组字面量，不需要像对象一个使用key属性。 let arr = [1, 2, 3]  //解构前2个元素  const [a, b] = arr  console.log(a,b) //1 2  //解构中间的元素  const [, b,] = arr  console.log(b) // 2 解构赋值 如果你没有看明白上面说到的对象解构赋值的含义，那么看完下面的数组解构赋值，或许你会有比较清晰的理解。 这个例子中，正常情况下打印a的值是haha，但是将数组arr的第一个元素解构赋值给a，a的值就变成了1。 //初始化一个变量a  let a = haha;  //定义一个数组  let arr = [1, 2, 3];  //解构赋值a，将arr数组的第一个元素解构赋值给a，  [a] = arr;  console.log(a); // 1 使用解构赋值，还可以调换2个变量的值。 let a = 1, b = 2;  [a, b] = [b, a];  console.log(a, b); // 2 1 嵌套数组解构 let arr = [1, [2, 3], 4];  let [a, [,b]] = arr;  console.log(a, b) // 1 3  //实际解构过程，左边的变量和右边的数组元素一一对应下标。  var a = arr[0],  _arr$ = arr[1],  b = _arr$[1]; 不定元素解构 三个点的解构赋值必须放在所有解构元素的最末尾，否则报错。 let arr = [1, 2, 3, 4];  let [...a] = arr;  console.log(a) //[1,2,3,4] 这种做法就是克隆arr数组。  混合解构 混合解构指的是对象和数组混合起来，执行解构操作，没什么难度。 let obj = {  a: {  id: 1  },  b: [2, 3]  }  const {  a: {id},  b:[...arr]  } = obj;  console.log(id, arr) //id = 1, arr = [2, 3]  解构参数 当给函数传递参数时，我们可以对每个参数进行解构，我给option的参数设置了默认值，这样可以防止没有给option传参导致的报错情况。 function Ajax(url, options) {  const {timeout = 0, jsonp = true} = options  console.log(url, timeout, jsonp)  };  Ajax('baidu.com', {  timeout: 1000,  jsonp: false  }) // baidu.com 1000 false 总结 本章讲解了对象解构赋值和数组解构赋值，以及对象和数组混合情况下的解构赋值操作，最后一个知识点是解构函数的参数。 六、Symbol和Symbol属性 在ES5的时代，对象的key只能是字符串String类型。有人就想搞事，把key改成其他数据类型，这不是瞎折腾吗？ES组织的大神们为了对付这类搞事的人，就指定了一个新的数据类型：Symbol。 原始数据类型 学习Symbol之前，让我们回忆一下你曾经用过的原始数据类型，只有5个，别搞错了。 null、undefined 是不是面试的时候有人问过你这两者的区别？问这种问题的人很无聊，你要是和他当同事，真是受罪。 Number 数字类型  const a = 10  typeof a // number String 字符串  const a = 'haha'  typeof a // string boolean 布尔型 const a = true, b = false Symbol Symbol 是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。Symbol 对象是一个 symbol primitive data type 的隐式对象包装器。 Symbol的语法格式： Symbol([description]) //description是可选的 创建一个Symbol： const name = Symbol();  const name1 = Symbol('sym1');  console.log(name, name1) // Symbol() Symbol(sym1) Symbol不能使用new const name = new Symbol(); //不可以这样做。  //Symbol is not a constructor 使用Symbol： 使用Number的时候，我们可以这样写： const b = Number(10) // 10  //简写  const b = 10 同理，使用Symbol，我们可以这样： const name1 = Symbol('sym1'); // Symbol(sym1) 在所有使用可计算属性名的地方，都能使用Symbol类型。比如在对象中的key。 const name = Symbol('name');  const obj = {  [name]: haha  }  console.log(obj[name]) // haha 你还可以使用Object.defineProperty()和Object.defineProperties()方法。这2个方法是对象的方法，但是作为Symbol类型key，也不影响使用。 // 设置对象属性只读。  Object.defineProperty(obj, name, {writable: false}) 这2个方法非常有用，在react源码中，使用了大量的只读属性的对象。以下是从react源码截取的一段代码，设置了props对象只读。但是react仍旧使用字符串作为key，并不用Symbol。 Object.defineProperty(props, 'key', {  get: warnAboutAccessingKey,  configurable: true  }); Symbol全局共享 Symbol有点特殊，在js文件中定义的Symbol，并不能在其他文件直接共享。 ES6提供了一个注册机制，当你注册Symbol之后，就能在全局共享注册表里面的Symbol。Symbol的注册表和对象表很像，都是key、value结构，只不过这个value是Symbol值。 （key, Symbol） 语法： Symbol.for() //只有一个参数 还有一个方法是获取注册表的Symbol。 语法： Symbol.keyFor() //只有一个参数，返回的是key 从注册表获取全局共享的Symbol  let name = Symbol.for('name');  let name1 = Symbol.for('name1');  let name2 = Symbol.for('name2');  console.log(Symbol.keyFor(name)) // name  console.log(Symbol.keyFor(name1)) // name1  console.log(Symbol.keyFor(name2)) // name2 注意：如果要防止Symbol命名重复问题，可以加上前缀。如：hyy.name Symbol与类型强制转换 JavaScript中的类型可以自动转换。比如Number转换成字符串。 let a = 1;  console.log(typeof a); // number  console.log(a + ' haha') // '1haha' 但是注意了，Symbol不支持这种转换。Symbol就是这么拽啊！ let a = Symbol('a');  console.log(typeof a);  console.log(a + ' haha') // Cannot convert a Symbol value to a string Symbol检索 在对象中获取字符串的key时，可以使用Object.keys()或Object. getOwnPropertyNames()方法获取key,但是使用Symbol做key时，你就只能使用ES6新增的方法来获取了。 let a = Symbol('a'); let b = Symbol('b'); let obj = {  [a]:123,  [b]:45  } const symbolsKey = Object.getOwnPropertySymbols(obj);  for(let value of symbolsKey) {  console.log(obj[value]) } 总结 Symbol是JavaScript的原始数据类型，一个全新的数据类型，和对象、数字、字符串等完全不一样，它必须通过Symbol()创建。 七、Set和Map Set  Set是有序列表，含有相互独立的非重复值。 创建一个Set集合 let set = new Set();  console.log(set);  //在浏览器控制台的输出结果  Set(0) {}  size:(...)  __proto__:Set  [[Entries]]:Array(0)  length:0 看起来像个对象，那么现在我们在控制台打印一个对象，对比一下两者有什么不同。 let obj = new Object()  console.log(obj)  //在控制台输出对象  Object {}  __proto__: 从输出结果看，Set和Object有明显的区别，反正他们就不是一个东西。 接着，我们看一下Set的原型有哪些：    原型  含义     Set.prototype.size  返回Set对象的值的个数。    Set.prototype.add(value)  在Set对象尾部添加一个元素。返回该Set对象。    Set.prototype.entries()  返回一个新的迭代器对象，该对象包含Set对象中的按插入顺序排列的所有元素的值的[value, value]数组。为了使这个方法和Map对象保持相似， 每个值的键和值相等。    Set.prototype.forEach(callbackFn[, thisArg])  按照插入顺序，为Set对象中的每一个值调用一次callBackFn。如果提供了thisArg参数，回调中的this会是这个参数。    Set.prototype.has(value)  返回一个布尔值，表示该值在Set中存在与否。   在例子中使用这几个方法测试一下： let set = new Set();  set.add('haha');  set.add(Symbol('haha'));  console.log(set.size); //2  console.log(set); Set(2) {haha, Symbol(haha)}  size:(...)  __proto__:Set  [[Entries]]:Array(2)   0:haha   1:Symbol(haha)  length:2   console.log(set.has('haha')) // true 到这里，你会发现Set像数组，又像一个对象，但又不完全是。 迭代Set Set既然提供了entries和forEach方法，那么他就是可迭代的。 但如果你使用for in来迭代Set，你不能这样做： for(let i in sets) {  console.log(i); //undefined  } for in迭代的是对象的key，而在Set中的元素没有key 使用for of来遍历 for(let value of sets) {  console.log(value);  }  //haha  //Symbol(haha)  //如果你需要key，则使用下面这种方法  for(let [key, value] of sets.entries()) {  console.log(value, key);  } //haha haha  //Symbol(haha) Symbol(haha) forEach操作Set： Set本身没有key，而forEach方法中的key被设置成了元素本身。 sets.forEach((value, key) =&gt; {  console.log(value, key);  });  //haha haha  //Symbol(haha) Symbol(haha)  sets.forEach((value, key) =&gt; {  console.log(Object.is(value, key));  }); //true true Set和Array的转换 Set和数组太像了，Set集合的特点是没有key，没有下标，只有size和原型以及一个可迭代的不重复元素的类数组。既然这样，我们就可以把一个Set集合转换成数组，也可以把数组转换成Set。 //数组转换成Set  const arr = [1, 2, 2, '3', '3']  let set = new Set(arr);  console.log(set) // Set(3) {1, 2, 3} //Set转换成数组  let set = new Set();  set.add(1);  set.add('2');  console.log(Array.from(set)) // (2) [1, 2] js面试中，经常会考的一道数组去重题目，就可以使用Set集合的不可重复性来处理。经测试只能去重下面3种类型的数据。 const arr = [1, 1, 'haha', 'haha', null, null]  let set = new Set(arr);  console.log(Array.from(set)) // [1, 'haha', null]  console.log([...set]) // [1, 'haha', null] Weak Set集合 Set集合本身是强引用，只要new Set()实例化的引用存在，就不释放内存，这样一刀切肯定不好啊，比如你定义了一个DOM元素的Set集合，然后在某个js中引用了该实例，但是当页面关闭或者跳转时，你希望该引用应立即释放内存，Set不听话，那好，你还可以使用 Weak Set 语法： new WeakSet([iterable]); 和Set的区别 1、WeakSet 对象中只能存放对象值, 不能存放原始值, 而 Set 对象都可以. 2、WeakSet 对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, WeakSet 对象是无法被枚举的, 没有办法拿到它包含的所有元素. 使用 let set = new WeakSet();  const class_1 = {}, class_2 = {};  set.add(class_1);  set.add(class_2);  console.log(set) // WeakSet {Object {}, Object {}}  console.log(set.has(class_1)) // true  console.log(set.has(class_2)) // true Map  Map是存储许多键值对的有序列表，key和value支持所有数据类型。 创建Map 如果说Set像数组，那么Map更像对象。而对象中的key只支持字符串，Map更加强大，支持所有数据类型，不管是数字、字符串、Symbol等。 // 一个空Map集合  let map = new Map()  console.log(map) 对比Set集合的原型，Map集合的原型多了set()和get()方法，注意set()和Set集合不是一个东西。Map没有add，使用set()添加key，value，在Set集合中，使用add()添加value，没有key。 let map = new Map();  map.set('name', 'haha');  map.set('id', 10);  console.log(map)  // 输出结果  Map(2) {name =&gt; haha, id =&gt; 10}  size:(...)  __proto__:Map  [[Entries]]:Array(2)   0:{name =&gt; haha}   1:{id =&gt; 10}  length:2 console.log(map.get('id')) // 10  console.log(map.get('name')) // haha 使用对象做key let map = new Map();  const key = {};  map.set(key, '谁知道这是个什么玩意');  console.log(map.get(key)) // 谁知道这是个什么玩意 Map同样可以使用forEach遍历key、value let map = new Map();  const key = {};  map.set(key, '这是个什么玩意');  map.set('name', 'haha');  map.set('id', 1);  map.forEach((value, key) =&gt; {  console.log(key, value)  })  //Object {} 这是个什么玩意  //name haha  //id 1 Weak Map 有强Map，就有弱鸡Map。 和Set要解决的问题一样，希望不再引用Map的时候自动触发垃圾回收机制。那么，你就需要Weak Map。 let map = new WeakMap();  const key = document.querySelector('.header');  map.set(key, '这是个什么玩意');  map.get(key) // 这是个什么玩意  //移除该元素  key.parentNode.removeChild(key);  key = null; 总结 Set集合可以用来过滤数组中重复的元素，只能通过has方法检测指定的值是否存在，或者是通过forEach处理每个值。 Weak Set集合存放对象的弱引用，当该对象的其他强引用被清除时，集合中的弱引用也会自动被垃圾回收机制回收，追踪成组的对象是该集合最好的使用方式。 Map集合通过set()添加键值对，通过get()获取键值，你可以把它看成是比Object更加强大的对象。 Weak Map集合只支持对象类型的key，所有key都是弱引用，当该对象的其他强引用被清除时，集合中的弱引用也会自动被垃圾回收机制回收，为那些实际使用与生命周期管理分离的对象添加额外信息是非常适合的使用方式。 八、迭代器（Iterator） 迭代器 ES5实现迭代器  迭代器是一种特殊对象，每一个迭代器对象都有一个next()，该方法返回一个对象，包括value和done属性。 ES5实现迭代器的代码如下： //实现一个返回迭代器对象的函数，注意该函数不是迭代器，返回结果才叫做迭代器。  function createIterator(items) {  var i = 0;  return {  next() {   var done = (i &gt;= items.length); // 判断i是否小于遍历的对象长度。   var value = !done ? items[i++] : undefined; //如果done为false，设置value为当前遍历的值。   return {   done,   value   }  }  }  }  const a = createIterator([1, 2, 3]);  //该方法返回的最终是一个对象，包含value、done属性。  console.log(a.next()); //{value: 1, done: false}  console.log(a.next()); //{value: 2, done: false}  console.log(a.next()); //{value: 3, done: false}  console.log(a.next()); //{value: undefined, done: true} 生成器（Generator） 生成器是函数：用来返回迭代器。 这个概念有2个关键点，一个是函数、一个是返回迭代器。这个函数不是上面ES5中创建迭代器的函数，而是ES6中特有的，一个带有*（星号）的函数，同时你也需要使用到yield。 //生成器函数，ES6内部实现了迭代器功能，你要做的只是使用yield来迭代输出。  function *createIterator() {  yield 1;  yield 2;  yield 3;  }  const a = createIterator();  console.log(a.next()); //{value: 1, done: false}  console.log(a.next()); //{value: 2, done: false}  console.log(a.next()); //{value: 3, done: false}  console.log(a.next()); //{value: undefined, done: true} 生成器的yield关键字有个神奇的功能，就是当你执行一次next()，那么只会执行一个yield后面的内容，然后语句终止运行。 在for循环中使用迭代器 即使你是在for循环中使用yield关键字，也会暂停循环。 function *createIterator(items) {  for(let i = 0; i &lt; items.length; i++) {  yield items[i]  }  }  const a = createIterator([1, 2, 3]);  console.log(a.next()); //{value: 1, done: false} yield使用限制 yield只可以在生成器函数内部使用，如果在非生成器函数内部使用，则会报错。 function *createIterator(items) {  //你应该在这里使用yield  items.map((value, key) =&gt; {  yield value //语法错误，在map的回调函数里面使用了yield  })  }  const a = createIterator([1, 2, 3]);  console.log(a.next()); //无输出 生成器函数表达式 函数表达式很简单，就是下面这种写法，也叫匿名函数，不用纠结。 const createIterator = function *() {  yield 1;  yield 2;  }  const a = createIterator();  console.log(a.next()); 在对象中添加生成器函数 一个对象长这样： const obj = {} 我们可以在obj中添加一个生成器，也就是添加一个带星号的方法： const obj = {  a: 1,  *createIterator() {  yield this.a  }  }  const a = obj.createIterator();  console.log(a.next()); //{value: 1, done: false} 可迭代对象和for of循环 再次默读一遍，迭代器是对象，生成器是返回迭代器的函数。 凡是通过生成器生成的迭代器，都是可以迭代的对象(可迭代对象具有Symbol.iterator属性)，也就是可以通过for of将value遍历出来。 function *createIterator() {  yield 1;  yield 2;  yield 3;  }  const a = createIterator();  for(let value of a) {  console.log(value)  }  // 1 2 3 上面的例子告诉我们生成器函数返回的迭代器是一个可以迭代的对象。其实我们这里要研究的是Symbol.iterator的用法。 function *createIterator() {  yield 1;  yield 2;  yield 3;  }  const a = createIterator(); //a是一个迭代器  const s = a[Symbol.iterator]();//使用Symbol.iterator访问迭代器  console.log(s.next()) //{value: 1, done: false} Symbol.iterator还可以用来检测一个对象是否可迭代 typeof obj[Symbol.iterator] === function 创建可迭代对象 在ES6中，数组、Set、Map、字符串都是可迭代对象。 默认情况下定义的对象（object）是不可迭代的，但是可以通过Symbol.iterator创建迭代器。 const obj = {  items: []  }  obj.items.push(1);//这样子虽然向数组添加了新元素，但是obj不可迭代  for (let x of obj) {  console.log(x) // _iterator[Symbol.iterator] is not a function  } //接下来给obj添加一个生成器，使obj成为一个可以迭代的对象。  const obj = {  items: [],  *[Symbol.iterator]() {  for (let item of this.items) {   yield item;  }  }  }  obj.items.push(1)  //现在可以通过for of迭代obj了。  for (let x of obj) {  console.log(x)  } 内建迭代器 上面提到了，数组、Set、Map都是可迭代对象，即它们内部实现了迭代器，并且提供了3种迭代器函数调用。 1、entries() 返回迭代器：返回键值对 //数组  const arr = ['a', 'b', 'c'];  for(let v of arr.entries()) {  console.log(v)  }  // [0, 'a'] [1, 'b'] [2, 'c']  //Set  const arr = new Set(['a', 'b', 'c']);  for(let v of arr.entries()) {  console.log(v)  }  // ['a', 'a'] ['b', 'b'] ['c', 'c'] //Map  const arr = new Map();  arr.set('a', 'a');  arr.set('b', 'b');  for(let v of arr.entries()) {  console.log(v)  }  // ['a', 'a'] ['b', 'b'] 2、values() 返回迭代器：返回键值对的value //数组  const arr = ['a', 'b', 'c'];  for(let v of arr.values()) {  console.log(v)  }  //'a' 'b' 'c' //Set  const arr = new Set(['a', 'b', 'c']);  for(let v of arr.values()) {  console.log(v)  }  // 'a' 'b' 'c' //Map  const arr = new Map();  arr.set('a', 'a');  arr.set('b', 'b');  for(let v of arr.values()) {  console.log(v)  }  // 'a' 'b' 3、keys() 返回迭代器：返回键值对的key //数组  const arr = ['a', 'b', 'c'];  for(let v of arr.keys()) {  console.log(v)  }  // 0 1 2  //Set  const arr = new Set(['a', 'b', 'c']);  for(let v of arr.keys()) {  console.log(v)  }  // 'a' 'b' 'c' //Map  const arr = new Map();  arr.set('a', 'a');  arr.set('b', 'b');  for(let v of arr.keys()) {  console.log(v)  }  // 'a' 'b' 虽然上面列举了3种内建的迭代器方法，但是不同集合的类型还有自己默认的迭代器，在for of中，数组和Set的默认迭代器是values()，Map的默认迭代器是entries()。 for of循环解构 对象本身不支持迭代，但是我们可以自己添加一个生成器，返回一个key，value的迭代器，然后使用for of循环解构key和value。 const obj = {  a: 1,  b: 2,  *[Symbol.iterator]() {  for(let i in obj) {   yield [i, obj[i]]  }  }  }  for(let [key, value] of obj) {  console.log(key, value)  }  // 'a' 1, 'b' 2 字符串迭代器 const str = 'abc';  for(let v of str) {  console.log(v)  }  // 'a' 'b' 'c' NodeList迭代器 迭代器真是无处不在啊，dom节点的迭代器你应该已经用过了。  const divs = document.getElementsByTagName('div');  for(let d of divs) {  console.log(d)  } 展开运算符和迭代器 const a = [1, 2, 3];  const b = [4, 5, 6];  const c = [...a, ...b]  console.log(c) // [1, 2, 3, 4, 5, 6] 高级迭代器功能 1、传参 生成器里面有2个yield，当执行第一个next()的时候，返回value为1，然后给第二个next()传入参数10，传递的参数会替代掉上一个next()的yield返回值。在下面的例子中就是first。 function *createIterator() {  let first = yield 1;  yield first + 2;  }  let i = createIterator();  console.log(i.next()); // {value: 1, done: false}  console.log(i.next(10)); // {value: 12, done: false} 2、在迭代器中抛出错误 function *createIterator() {  let first = yield 1;  yield first + 2;  }  let i = createIterator();  console.log(i.next()); // {value: 1, done: false}  console.log(i.throw(new Error('error'))); // error  console.log(i.next()); //不再执行 3、生成器返回语句 生成器中添加return表示退出操作。  function *createIterator() {  let first = yield 1;  return;  yield first + 2;  }  let i = createIterator();  console.log(i.next()); // {value: 1, done: false}  console.log(i.next()); // {value: undefined, done: true} 4、委托生成器 生成器嵌套生成器 function *aIterator() {  yield 1;  }  function *bIterator() {  yield 2;  }  function *cIterator() {  yield *aIterator()  yield *bIterator()  }  let i = cIterator();  console.log(i.next()); // {value: 1, done: false}  console.log(i.next()); // {value: 2, done: false} 异步任务执行器 ES6之前，我们使用异步的操作方式是调用函数并执行回调函数。 书上举的例子挺好的，在nodejs中，有一个读取文件的操作，使用的就是回调函数的方式。 var fs = require(fs);  fs.readFile(xx.json, function(err, contents) {  //在回调函数中做一些事情  }) 任务执行器是一个函数，用来循环执行生成器，因为我们知道生成器需要执行N次next()方法，才能运行完，所以我们需要一个自动任务执行器帮我们做这些事情，这就是任务执行器的作用。 下面我们编写一个异步任务执行器。  //taskDef是一个生成器函数，run是异步任务执行器  function run(taskDef) {  let task = taskDef(); //调用生成器  let result = task.next(); //执行生成器的第一个next()，返回result  function step() {  if(!result.done) {  //如果done为false，则继续执行next()，并且循环step，直到done为true退出。   result = task.next(result.value);   step();  }  }  step(); //开始执行step()  } 测试一下我们编写的run方法，我们不再需要console.log N个next了，因为run执行器已经帮我们做了循环执行操作： run(function *() {  let value = yield 1;  value = yield value + 20;  console.log(value) // 21  }) 总结 本章讲了3个概念，迭代器、生成器、任务执行器。 迭代器是一个对象。 生成器是一个函数，它最终返回迭代器。 任务执行器一个函数（或者也叫生成器的回调函数），帮我们自动执行生成器的内部运算，最终返回迭代器。  九、类 ES5中的近类结构 ES5以及之前的版本，没有类的概念，但是聪明的JavaScript开发者，为了实现面向对象，创建了特殊的近类结构。 ES5中创建类的方法：新建一个构造函数，定义一个方法并且赋值给构造函数的原型。 'use strict';  //新建构造函数，默认大写字母开头  function Person(name) {  this.name = name;  }  //定义一个方法并且赋值给构造函数的原型  Person.prototype.sayName = function () {  return this.name;  };  var p = new Person('eryue');  console.log(p.sayName() // eryue  ); ES6 class类 class Person {  //新建构造函数  constructor(name) {  this.name = name //私有属性  }  //定义一个方法并且赋值给构造函数的原型  sayName() {  return this.name  }  }  let p = new Person('eryue')  console.log(p.sayName()) // eryue 和ES5中使用构造函数不同的是，在ES6中，我们将原型的实现写在了类中，但本质上还是一样的，都是需要新建一个类名，然后实现构造函数，再实现原型方法。 私有属性：在class中实现私有属性，只需要在构造方法中定义this.xx = xx。 类声明和函数声明的区别和特点 1、函数声明可以被提升，类声明不能提升。 2、类声明中的代码自动强行运行在严格模式下。 3、类中的所有方法都是不可枚举的，而自定义类型中，可以通过Object.defineProperty()手工指定不可枚举属性。 4、每个类都有一个[[construct]]的方法。 5、只能使用new来调用类的构造函数。 6、不能在类中修改类名。 类表达式 类有2种表现形式：声明式和表达式。 //声明式  class B {  constructor() {}  } //匿名表达式  let A = class {  constructor() {}  }  //命名表达式，B可以在外部使用，而B1只能在内部使用  let B = class B1 {  constructor() {}  } 类是一等公民 JavaScript函数是一等公民，类也设计成一等公民。 1、可以将类作为参数传入函数。 //新建一个类  let A = class {  sayName() {  return 'eryue'  }  }  //该函数返回一个类的实例  function test(classA) {  return new classA()  }  //给test函数传入A  let t = test(A)  console.log(t.sayName()) // eryue 2、通过立即调用类构造函数可以创建单例。 let a = new class {  constructor(name) {  this.name = name  }  sayName() {  return this.name  }  }('eryue')  console.log(a.sayName()) // eryue 访问器属性 类支持在原型上定义访问器属性。 class A {  constructor(state) {  this.state = state  }  // 创建getter  get myName() {  return this.state.name  }  // 创建setter  set myName(name) {  this.state.name = name  }  }  // 获取指定对象的自身属性描述符。自身属性描述符是指直接在对象上定义（而非从对象的原型继承）的描述符。  let desriptor = Object.getOwnPropertyDescriptor(A.prototype, myName)  console.log(get in desriptor) // true  console.log(desriptor.enumerable) // false 不可枚举 可计算成员名称 可计算成员是指使用方括号包裹一个表达式，如下面定义了一个变量m，然后使用[m]设置为类A的原型方法。 let m = sayName  class A {  constructor(name) {  this.name = name  }  [m]() {  return this.name  }  }  let a = new A(eryue)  console.log(a.sayName()) // eryue 生成器方法 回顾一下上一章讲的生成器，生成器是一个返回迭代器的函数。在类中，我们也可以使用生成器方法。 class A {  *printId() {  yield 1;  yield 2;  yield 3;  }  }  let a = new A()  let x = a.printId()  x.next() // {done: false, value: 1}  x.next() // {done: false, value: 2}  x.next() // {done: false, value: 3} 这个写法很有趣，我们新增一个原型方法稍微改动一下。 class A {  *printId() {  yield 1;  yield 2;  yield 3;  }  render() {  //从render方法访问printId，很熟悉吧，这就是react中经常用到的写法。  return this.printId()  }  }  let a = new A()  console.log(a.render().next()) // {done: false, value: 1} 静态成员 静态成员是指在方法名或属性名前面加上static关键字，和普通方法不一样的是，static修饰的方法不能在实例中访问，只能在类中直接访问。 class A {  constructor(name) {  this.name = name  }  static create(name) {  return new A(name)  }  }  let a = A.create(eryue)  console.log(a.name) // eryue  let t = new A()  console.log(t.create(eryue)) // t.create is not a function 继承与派生类 我们在写react的时候，自定义的组件会继承React.Component。 class A extends Component {  constructor(props){  super(props)  }  } A叫做派生类，在派生类中，如果使用了构造方法，就必须使用super()。 class Component {  constructor([a, b] = props) {  this.a = a  this.b = b  }  add() {  return this.a + this.b  }  }  class T extends Component {  constructor(props) {  super(props)  }  }  let t = new T([2, 3])  console.log(t.add()) // 5 关于super使用的几点要求 1、只可以在派生类中使用super。派生类是指继承自其它类的新类。 2、在构造函数中访问this之前要调用super()，负责初始化this。 class T extends Component {  constructor(props) {  this.name = 1 // 错误，必须先写super()  super(props)  }  } 3、如果不想调用super，可以让类的构造函数返回一个对象。 我们可以在继承的类中重写父类的方法。 class Component {  constructor([a, b] = props) {  this.a = a  this.b = b  }  //父类的add方法，求和  add() {  return this.a + this.b  }  }  class T extends Component {  constructor(props) {  super(props)  }  //重写add方法，求积  add() {  return this.a * this.b  }  }  let t = new T([2, 3])  console.log(t.add()) // 6 静态成员继承 父类中的静态成员，也可以继承到派生类中。静态成员继承只能通过派生类访问，不能通过派生类的实例访问。 class Component {  constructor([a, b] = props) {  this.a = a  this.b = b  }  static printSum([a, b] = props) {  return a + b  }  }  class T extends Component {  constructor(props) {  super(props)  }  }  console.log(T.printSum([2, 3])) // 5 内建对象的继承 有些牛逼的人觉得使用内建的Array不够爽，就希望ECMA提供一种继承内建对象的方法，然后那帮大神们就把这个功能添加到class中了。 class MyArray extends Array { }  let colors = new MyArray()  colors[0] = 1  console.log(colors) // [1] Symbol.species 该用法我还没有接触过，目前只知道在内建对象中使用了该方法，如果在类中调用this.constructor，使用Symbol.species可以让派生类重写返回类型。 在构造函数中使用new.target new.target通常表示当前的构造函数名。通常我们使用new.target来阻止直接实例化基类，下面是这个例子的实现。 class A {  constructor() {  //如果当前的new.target为A类，就抛出异常  if (new.target === A) {   throw new Error(error haha)  }  }  }  let a = new A()  console.log(a) // error haha 总结 本章只有一个知识点，那就是class的使用，最开始的声明class，到后面的继承派生类，都是非常常用的写法，还有静态成员的使用。  十、Promise 为什么要异步编程 我们在写前端代码时，经常会对dom做事件处理操作，比如点击、激活焦点、失去焦点等；再比如我们用ajax请求数据，使用回调函数获取返回值。这些都属于异步编程。 也许你已经大概知道JavaScript引擎单线程的概念，那么这种单线程模式和异步编程有什么关系呢？  JavaScript引擎中，只有一个主线程，当执行JavaScript代码块时，不允许其他代码块执行，而事件机制和回调机制的代码块会被添加到任务队列中，当符合某个触发回调或者事件的时候，就会执行该事件或者回调函数。 事件模型 浏览器初次渲染DOM的时候，我们会给一些DOM绑定事件函数，只有当触发了这些DOM事件函数，才会执行他们。 const btn = document.querySelector('.button')  btn.onclick = function(event) {  console.log(event)  } 回调模式 nodejs中可能非常常见这种回调模式，但是对于前端来说，ajax的回调是最熟悉不过了。ajax回调有多个状态，当响应成功和失败都有不同的回调函数。 $.post('/router', function(data) {  console.log(data)  }) 回调也可能带来一个问题，那就是地狱回调，不过幸运的是，我从进入前端界开始，就使用react，跳过了很多坑，特别是地狱回调，一直没有机会在工作中遇见到，真是遗憾。 Promise 事件函数没有问题，我们用的很爽，问题出在回调函数，尤其是指地狱回调，Promise的出现正是为了避免地狱回调带来的困扰。 Promise是什么 Promise的中文意思是承诺，也就是说，JavaScript对你许下一个承诺，会在未来某个时刻兑现承诺。 Promise生命周期 react有生命周期，vue也有生命周期，就连Promise也有生命周期，现在生命周期咋这么流行了。 Promise的生命周期：进行中（pending），已经完成（fulfilled），拒绝（rejected） Promise被称作异步结果的占位符，它不能直接返回异步函数的执行结果，需要使用then()，当获取异常回调的时候，使用catch()。 这次我们使用axios插件的代码做例子。axios是前端比较热门的http请求插件之一。 1、创建axios实例instance。  import axios from 'axios'  export const instance = axios.create() 2、使用axios实例 + Promise获取返回值。 const promise = instance.get('url')  promise.then(result =&gt; console.log(result)).catch(err =&gt; console.log(err)) 使用Promise构建函数创建新的Promise Promise构造函数只有一个参数，该参数是一个函数，被称作执行器，执行器有2个参数，分别是resolve()和reject()，一个表示成功的回调，一个表示失败的回调。 new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(5), 0)  }).then(v =&gt; console.log(v)) // 5 记住，Promise实例只能通过resolve或者reject函数来返回，并且使用then()或者catch()获取，不能在new Promise里面直接return，这样是获取不到Promise返回值的。 1、我们也可以使用Promise直接resolve(value)。 Promise.resolve(5).then(v =&gt; console.log(v)) // 5 2、也可以使用reject(value) Promise.reject(5).catch(v =&gt; console.log(v)) // 5 3、执行器错误通过catch捕捉。 new Promise(function(resolve, reject) {  if(true) {  throw new Error('error!!')  }  }).catch(v =&gt; console.log(v.message)) // error!! 全局的Promise拒绝处理 这里涉及到nodejs环境和浏览器环境的全局，主要说的是如果执行了Promise.reject()，浏览器或者node环境并不会强制报错，只有在你调用catch的时候，才能知道Promise被拒绝了。 这种行为就像是，你写了一个函数，函数内部有true和false两种状态，而我们希望false的时候抛出错误，但是在Promise中，并不能直接抛出错误， 无论Promise是成功还是拒绝状态，你获取Promise生命周期的方法只能通过then()和catch()。 nodejs环境： node环境下有个对象叫做process，即使你没写过后端node，如果写过前端node服务器，也应该知道可以使用process.ENV_NODE获取环境变量。为了监听Promise的reject（拒绝）情况，NodeJS提供了一个process.on()，类似jQuery的on方法，事件绑定函数。 process.on()有2个事件 unhandledRjection:在一个事件循环中，当Promise执行reject()，并且没有提供catch()时被调用。 正常情况下，你可以使用catch捕捉reject。  Promise.reject(It was my wrong!).catch(v =&gt; console.log(v)) 但是，有时候你不总是记得使用catch。你就需要使用process.on() let rejected  rejected = Promise.reject(It was my wrong!)  process.on(unhandledRjection, function(reason, promise) {  console.log(reason.message) // It was my wrong!  console.log(rejected === promise) // true  }) rejectionHandled:在一个事件循环后，当Promise执行reject，并且没有提供catch()时被调用。 let rejected  rejected = Promise.reject(new Error(It was my wrong!))  process.on(rejectionHandled, function(promise) {  console.log(rejected === promise) // true  }) 异同： 事件循环中、事件循环后，你可能很难理解这2个的区别，但是这不重要，重要的是，如果你通过了catch()方法来捕捉reject操作，那么，这2个事件就不会生效。 浏览器环境： 和node环境一样，都提供了unhandledRjection、rejectionHandled事件，不同的是浏览器环境是通过window对象来定义事件函数。 let rejected  rejected = Promise.reject(new Error(It was my wrong!))  window.rejectionHandled = function(event) {  console.log(event) // true  }  rejectionHandled() Promise链式调用 这个例子中，使用了3个then，第一个then返回 s * s，第二个then捕获到上一个then的返回值，最后一个then直接输出end。这就叫链式调用，很好理解的。我只使用了then()，实际开发中，你还应该加上catch()。 new Promise(function(resolve, reject) {  try {  resolve(5)  } catch (error) {  reject('It was my wrong!!!')  }  }).then(s =&gt; s * s).then(s2 =&gt; console.log(s2)).then(() =&gt; console.log('end'))  // 25 end Promise的其他方法 在Promise的构造函数中，除了reject()和resolve()之外，还有2个方法，Promise.all()、Promise.race()。 Promise.all() 前面我们的例子都是只有一个Promise，现在我们使用all()方法包装多个Promise实例。 语法很简单：参数只有一个，可迭代对象，可以是数组，或者Symbol类型等。 Promise.all(iterable).then().catch() 示例：传入3个Promise实例 Promise.all([  new Promise(function(resolve, reject) {  resolve(1)  }),  new Promise(function(resolve, reject) {  resolve(2)  }),  new Promise(function(resolve, reject) {  resolve(3)  })  ]).then(arr =&gt; {  console.log(arr) // [1, 2, 3]  }) Promise.race()语法和all()一样，但是返回值有所不同，race根据传入的多个Promise实例，只要有一个实例resolve或者reject，就只返回该结果，其他实例不再执行。 还是使用上面的例子，只是我给每个resolve加了一个定时器，最终结果返回的是3，因为第三个Promise最快执行。 Promise.race([  new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(1), 1000)  }),  new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(2), 100)  }),  new Promise(function(resolve, reject) {  setTimeout(() =&gt; resolve(3), 10)  })  ]).then(value =&gt; {  console.log(value) // 3  }) Promise派生 派生的意思是定义一个新的Promise对象，继承Promise方法和属性。 class MyPromise extends Promise {  //重新封装then()  success(resolve, reject) {  return this.then(resolve, reject)  }  //重新封装catch()  failer(reject) {  return this.catch(reject)  }  } 接着我们来使用一下这个派生类。 ​  new MyPromise(function(resolve, reject) {  resolve(10)  }).success(v =&gt; console.log(v)) // 10 如果只是派生出来和then、catch一样的方法，我想，你不会干这么无聊的事情。 Promise和异步的联系 Promise本身不是异步的，只有他的then()或者catch()方法才是异步，也可以说Promise的返回值是异步的。通常Promise被使用在node，或者是前端的ajax请求、前端DOM渲染顺序等地方。 ###比Promise更牛逼的异步方案 在本章你只需要了解有async这个未来的方案，推荐不会的赶紧去网上找资料学，反正我是已经在实际项目中全面开展async了。 async function a() {  await function() {}  } 十一、Proxy（代理）和 Reflection（反射） API 反射的概念 Reflect 是一个内置的对象，它提供可拦截JavaScript操作的方法。方法与代理处理程序的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。 new Reflect() //错误的写法 反射的使用 Reflect提供了一些静态方法，静态方法是指只能通过对象自身访问的的方法 静态方法列表 1、Reflect.apply() 2、Reflect.construct() 3、Reflect.defineProperty() 4、Reflect.deleteProperty() 5、Reflect.enumerate() 6、Reflect.get() 7、Reflect.getOwnPropertyDescriptor() 8、Reflect.getPrototypeOf() 9、Reflect.has() 10、Reflect.isExtensible() 11、Reflect.ownKeys() 12、Reflect.preventExtensions() 13、Reflect.set() 14、Reflect.setPrototypeOf() 静态方法的使用 demo1：使用Reflect.get()获取目标对象指定key的value。  let obj = {  a: 1  };  let s1 = Reflect.get(obj, a)  console.log(s1) // 1 demo2:使用Reflect.apply给目标函数floor传入指定的参数。  const s2 = Reflect.apply(Math.floor, undefined, [1.75]); console.log(s2) // 1 进一步理解Reflect 看了上面的例子和方法，我们知道Reflect可以拦截JavaScript代码，包括拦截对象，拦截函数等，然后对拦截到的对象或者函数进行读写等操作。 比如demo1的get()方法，拦截obj对象，然后读取key为a的值。当然，不用反射也可以读取a的值。 再看demo2的apply()方法，这个方法你应该比较了解了，和数组中使用apply不同的是，Reflect.apply()提供了3个参数，第一个参数是反射的函数，后面2个参数才是和数组的apply一致。demo2的例子我们可以理解成是拦截了Math.floor方法，然后传入参数，将返回值赋值给s2，这样我们就能在需要读取这个返回值的时候调用s2。 //数组使用apply  const arr = [1, 2, 3]  function a() {  return Array.concat.apply(null, arguments)  }  const s = a(arr)  console.log(s) // [1, 2 ,3] 其实Reflect的作用和我们下面要讲的Proxy是差不多的。 代理 Proxy 语法 let p = new Proxy(target, handler); target：一个目标对象(可以是任何类型的对象，包括本机数组，函数，甚至另一个代理)用Proxy来包装。 handler：一个对象，其属性是当执行一个操作时定义代理的行为的函数。 代理的使用 基础demoProxy的demo有很多，我们只分析基础demo，主要看new Proxy({}, handler)的操作，指定目标obj对象，然后handler对象执行get()操作，get()返回值的判断是，如果name是target目标对象的属性，则返回target[name]的值，否则返回37，最后测试的时候，p.a是对象p的key，所以返回a的value，而p.b不存在，返回37。  const obj = {  a: 10  }  let handler = {  get: function(target, name){   console.log('test: ', target, name)   // test: {a:10} a   // test: {a:10} b   return name in target ? target[name] : 37  }  }  let p = new Proxy(obj, handler)  console.log(p.a, p.b) // 10 37 这个例子的作用是拦截目标对象obj，当执行obj的读写操作时，进入handler函数进行判断，如果读取的key不存在，则返回默认值。 我们使用一些http-proxy插件或者webpack的时候，有时候需要访问某个api时，跳转到指定的url，这种方式也能解决跨域访问。这种代理模式和Proxy的代理有异曲同工之妙。但是，别混为一体了。 module.exports = {  devServer: {  proxy: [   {    context: /api/*, //代理API    target: 'https://www.hyy.com', //目标URL    secure: false   }  ]  }  } 总结 无论是反射还是代理，除了他们使用方法不同之外，他们所作的事情非常相似，都可以理解成拦截某个东西，然后执行某个函数操作，再返回函数操作的结果。 大部分前端在日常业务需求中，几乎很少使用到这2个API，实际使用场景还得在以后的开发中慢慢挖掘。  十二、模块化 模块的定义 模块是自动运行在严格模式下并且没有办法退出运行的JavaScript代码。 模块可以是函数、数据、类，需要指定导出的模块名，才能被其他模块访问。  //数据模块  const obj = {a: 1}  //函数模块  const sum = (a, b) =&gt; {  return a + b  }  //类模块  class My extends React.Components {  } 模块的导出 给数据、函数、类添加一个export，就能导出模块。一个配置型的JavaScript文件中，你可能会封装多种函数，然后给每个函数加上一个export关键字，就能在其他文件访问到。  //数据模块  export const obj = {a: 1}  //函数模块  export const sum = (a, b) =&gt; {  return a + b  }  //类模块  export class My extends React.Components {  } 模块的引用 在另外的js文件中，我们可以引用上面定义的模块。使用import关键字，导入分2种情况，一种是导入指定的模块，另外一种是导入全部模块。 1、导入指定的模块。 //导入obj数据，My类  import {obj, My} from './xx.js'  //使用  console.log(obj, My) 2、导入全部模块 //导入全部模块  import * as all from './xx.js'  //使用  console.log(all.obj, all.sun(1, 2), all.My) 默认模块的使用 如果给我们的模块加上default关键字，那么该js文件默认只导出该模块，你还需要把大括号去掉。 //默认模块的定义  function sum(a, b) {  return a + b  }  export default sum  //导入默认模块  import sum from './xx.js' 模块的使用限制 不能在语句和函数之内使用export关键字，只能在模块顶部使用，作为react和vue开发者的你，这个限制你应该很熟悉了。 在react中，模块顶部导入其他模块。 import react from 'react' 在vue中，模块顶部导入其他模块。 &lt;script&gt;  import sum from './xx.js'  &lt;/script&gt; 修改模块导入和导出名 有2种修改方式，一种是模块导出时修改，一种是导入模块时修改。 1、导出时修改： function sum(a, b) {  return a + b  }  export {sum as add} import { add } from './xx.js'  add(1, 2) 2、导入时修改： function sum(a, b) {  return a + b  }  export sum import { sum as add } from './xx.js'  add(1, 2) 无绑定导入 当你的模块没有可导出模块，全都是定义的全局变量的时候，你可以使用无绑定导入。 模块：  let a = 1  const PI = 3.1314 无绑定导入：  import './xx.js'  console.log(a, PI) 浏览器加载模块 有用过webpack打包js模块的同学可能有经验，使用webpack打包了多个js文件，然后放到HTML使用script加载时，如果加载顺序不对，就会出现找不到模块的错误。 这是因为模块之间是有依赖关系的，就像你使用jQuery的时候，必须先加载jQuery的代码，才能使用jQuery提供的方法。 加载模块的方法，总是先加载模块1，再加载模块2，因为module类型默认使用defer属性。  &lt;script type=module src=module1.js&gt;&lt;/script&gt;  &lt;script type=module src=module2.js&gt;&lt;/script&gt; 总结 模块还有很多有意思的特性，对react和vue开发有一定经验的人对这些基本知识应该了如指掌，新手不了解也不用太心急，写几个module.js做一下尝试。如果浏览器报错，不能识别export模块，你可能需要先加载babel的js插件来编译它。  十三、补充（知识点） ES5提供的数组已经很强大，但是ES6中继续改进了一些，主要是增加了新的数组方法，所以这章的知识非常少。 创建数组 ES5中创建数组的方式：数组字面量、new一个数组。 const arr1 = [] //数组字面量  const arr2 = new Array() //new构建 ES6创建数组：Array.of()、Array.from() Array.of() ES5中new一个人数组的时候，会存在一个令人困惑的情况。当new一个数字的时候，生成的是一个长度为该数字的数组，当new一个字符串的时候，生成的是该字符串为元素的数组。 const a = new Array(2)  const b = new Array(2)  console.log(a, b) //[undefined, undefined] [2] 这样一来，导致new Array的行为是不可预测的，Array.of()出现为的就是解决这个情况。 const c = Array.of(2)  const d = Array.of(2)  console.log(c, d) // [2] [2] 使用Array.of()创建的数组传入的参数都是作为数组的元素，而不在是数组长度，这样就避免了使用上的歧义。 Array.from() 如果说Array.of()是创建一个新数组，而Array.from()是将类数组转换成数组。 下面的例子讲的是将arguments转换成数组。arguments是类数组对象，他表示的是当前函数的所有参数，如果函数没有参数，那么arguments就为空。 function test(a, b) {  let arr = Array.from(arguments)  console.log(arr)  }  test(1, 2) //[1, 2] 映射转换：Array.from(arg1, arg2)，我们可以给该方法提供2个参数，第二个参数作为第一个参数的转换。看个简单例子你就懂了。 function test(a, b) {  let arr = Array.from(arguments, value =&gt; value + 2)  console.log(arr)  }  test(1, 2) //[3, 4] Array.from还可以设置第三个参数，指定this。 Array.from()转换可迭代对象：这个用法只需要一个例子，数组去重。 function test() {  return Array.from(new Set(...arguments))  }  const s = test([1, 2, 3, 3, 2])  console.log(s) // [1,2,3] 给数组添加新方法 ES6给数组添加了几个新方法：find()、findIndex()、fill()、copyWithin()。 1、find()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它，并且终止搜索。 const arr = [1, 2, 3, 3, 2]  console.log(arr.find(n =&gt; typeof n === number)) // 1 2、findIndex()：传入一个回调函数，找到数组中符合当前搜索规则的第一个元素，返回它的下标，终止搜索。 const arr = [1, 2, 3, 3, 2]  console.log(arr.findIndex(n =&gt; typeof n === number)) // 0 3、fill()：用新元素替换掉数组内的元素，可以指定替换下标范围。 arr.fill(value, start, end) 测试一下 const arr = [1, 2, 3]  console.log(arr.fill(4)) // [4, 4, 4] 不指定开始和结束，全部替换  const arr1 = [1, 2, 3]  console.log(arr1.fill(4, 1)) // [1, 4, 4] 指定开始位置，从开始位置全部替换  const arr2 = [1, 2, 3]  console.log(arr2.fill(4, 0, 2)) // [4, 4, 3] 指定开始和结束位置，替换当前范围的元素 4、copyWithin()：选择数组的某个下标，从该位置开始复制数组元素，默认从0开始复制。也可以指定要复制的元素范围。 arr.copyWithin(target, start, end) 测试一下  const arr = [1, 2, 3, 4, 5]  console.log(arr.copyWithin(3)) // [1,2,3,1,2] 从下标为3的元素开始，复制数组，所以4, 5被替换成1, 2  const arr1 = [1, 2, 3, 4, 5]  console.log(arr1.copyWithin(3, 1)) // [1,2,3,2,3] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，所以4, 5被替换成2, 3  const arr2 = [1, 2, 3, 4, 5]  console.log(arr2.copyWithin(3, 1, 2)) // [1,2,3,2,5] 从下标为3的元素开始，复制数组，指定复制的第一个元素下标为1，结束位置为2，所以4被替换成2 总结 以上内容是通过精读《深入理解ES6》一书和个别大佬文章总结，进行再次汇总，可能有点粗制滥造，但也是对自己所学进行一定的总结，收货颇多，又重新认识了一下ES6，very interesting! ",
      "url"      : "http://localhost:4000/2019/12/21/restudy-ES6/",
      "keywords" : "ES6"
    } ,
  
    {
      "title"    : "常见三大缓存问题分析及解决方案",
      "category" : "浏览器问题",
      "content": " 常见三大缓存问题不外乎就是缓存穿透、缓存击穿、缓存雪崩。三者的共同点都是高并发，缓存更新、缓存失效居多。而且三者也会相互恶化，导致问题更加严重，因此一旦有一个问题就需要马上解决，以免引起雪崩”。 缓存穿透 定义： 正常情况下，我们去查询数据都是存在。那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。这种查询不存在数据的现象我们称为缓存穿透。 解决方案： （1）存空值：之所以会发生穿透，就是因为缓存中没有存储这些空数据的key。从而导致每次查询都到数据库去了。那么我们就可以为这些key对应的值设置为null 丢到缓存里面去。后面再出现查询这个key 的请求的时候，直接返回null 。这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。 （2）BloomFilter：BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -&gt; 查 DB。 缓存击穿 定义： 缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个key正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为缓存击穿。 解决方案： 上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。 缓存雪崩 定义： 缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉。 解决方案： 首先，使用集群缓存，保证缓存服务的高可用这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。然后，ehcache本地缓存 + Hystrix限流&amp;降级,避免MySQL被打死使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。使用 Hystrix进行限流 &amp; 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。最后，开启Redis持久化机制，尽快恢复缓存集群一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。 ",
      "url"      : "http://localhost:4000/2020/01/12/cache-save-way/",
      "keywords" : "浏览器问题"
    } ,
  
    {
      "title"    : "js性能优化",
      "category" : "Javascript",
      "content": "参考文章 Web篇之JS性能优化 https://www.cnblogs.com/tianshu/p/10555921.html Javascript常见性能优化 https://www.cnblogs.com/sunshq/p/9232442.html JavaScript性能优化 DOM编程 https://www.cnblogs.com/strick/p/6769634.html ",
      "url"      : "http://localhost:4000/2020/01/13/js-performance-optimize/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "两栏定宽中间自适应",
      "category" : "HTML5",
      "content": "5种layout方案 &lt;!DOCTYPE html&gt; &lt;html lang=en&gt; &lt;head&gt;  &lt;meta charset=UTF-8 /&gt;  &lt;meta name=viewport content=width=device-width, initial-scale=1.0 /&gt;  &lt;title&gt;Document&lt;/title&gt;  &lt;style media=screen&gt;  .layout {  margin-top: 20px;  position: relative;  }  .layout article div {  min-height: 100px;  }  &lt;/style&gt; &lt;/head&gt; &lt;body&gt;  &lt;!-- 使用浮动 --&gt;  &lt;section class=layout float&gt;  &lt;style media=screen&gt;  .layout.float .left {   float: left;   width: 300px;   background: red;  }  .layout.float .right {   float: right;   width: 300px;   background: blue;  }  .layout.float .center {   background: yellow;  }  &lt;/style&gt;  &lt;article class=left-right-center&gt;  &lt;div class=left&gt;&lt;/div&gt;  &lt;div class=right&gt;&lt;/div&gt;  &lt;div class=center&gt;   &lt;h1&gt;浮动解决方案&lt;/h1&gt;  &lt;/div&gt;  &lt;/article&gt;  &lt;/section&gt;  &lt;!-- 使用定位 --&gt;  &lt;section class=layout absolute&gt;  &lt;style media=screen&gt;  .layout.absolute .left-center-right &gt; div {   position: absolute;  }  .layout.absolute .left {   left: 0;   width: 300px;   background: blue;  }  .layout.absolute .center {   left: 300px;   right: 300px;   background: yellow;  }  .layout.absolute .right {   right: 0;   width: 300px;   background: red;  }  &lt;/style&gt;  &lt;article class=left-center-right&gt;  &lt;div class=left&gt;&lt;/div&gt;  &lt;div class=center&gt;   &lt;h1&gt;定位解决方案&lt;/h1&gt;  &lt;/div&gt;  &lt;div class=right&gt;&lt;/div&gt;  &lt;/article&gt;  &lt;/section&gt;  &lt;!-- 使用flexbox --&gt;  &lt;section class=layout flexbox&gt;  &lt;style media=screen&gt;  .layout.flexbox {   margin-top: 140px;  }  .layout.flexbox .left-center-right {   display: flex;  }  .layout.flexbox .left {   width: 300px;   background: blue;  }  .layout.flexbox .center {   flex: 1;   background: yellow;  }  .layout.flexbox .right {   width: 300px;   background: red;  }  &lt;/style&gt;  &lt;article class=left-center-right&gt;  &lt;div class=left&gt;&lt;/div&gt;  &lt;div class=center&gt;   &lt;h1&gt;flexbox解决方案&lt;/h1&gt;  &lt;/div&gt;  &lt;div class=right&gt;&lt;/div&gt;  &lt;/article&gt;  &lt;/section&gt;  &lt;!-- 使用table --&gt;  &lt;section class=layout table&gt;  &lt;style media=screen&gt;  .layout.table .left-center-right {   width: 100%;   display: table;   height: 100px;  }  .layout.table .left-center-right &gt; div {   display: table-cell;  }  .layout.table .left {   width: 300px;   background: blueviolet;  }  .layout.table .center {   background: yellow;  }  .layout.table .right {   width: 300px;   background: red;  }  &lt;/style&gt;  &lt;article class=left-center-right&gt;  &lt;div class=left&gt;&lt;/div&gt;  &lt;div class=center&gt;   &lt;h1&gt;table解决方案&lt;/h1&gt;  &lt;/div&gt;  &lt;div class=right&gt;&lt;/div&gt;  &lt;/article&gt;  &lt;/section&gt; &lt;!-- 使用网格 --&gt;  &lt;section class=layout grid&gt;  &lt;style media=screen&gt;  .layout.grid .left-center-right {   display: grid;   width: 100%;   grid-template-rows: 100px;   grid-template-columns: 300px auto 300px;  }  .layout.grid .left {   background: brown;  }  .layout.grid .center {   background: yellow;  }  .layout.grid .right {   background: yellowgreen;  }  &lt;/style&gt;  &lt;article class=left-center-right&gt;  &lt;div class=left&gt;&lt;/div&gt;  &lt;div class=center&gt;   &lt;h1&gt;grid解决方案&lt;/h1&gt;  &lt;/div&gt;  &lt;div class=right&gt;&lt;/div&gt;  &lt;/article&gt;  &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; ",
      "url"      : "http://localhost:4000/2020/02/15/two-column-auto/",
      "keywords" : "HTML5"
    } ,
  
    {
      "title"    : "记录自制webApp中使用node实现接口路由的部分接口代码",
      "category" : "Node",
      "content": "注册的路由 router.post('/register', function(req, res) { // 读取请求参数数据 const { username, password } = req.body // 处理: 判断用户是否已经存在, 如果存在, 返回提示错误的信息, 如果不存在, 保存 // 查询(根据username) UserModel.findOne({ username }, function(err, user) {  // 如果user有值(已存在)  if (user) {  // 返回提示错误的信息  res.send({ code: 1, msg: '此用户已存在' })  } else {  // 没值(不存在)  // 保存  new UserModel({  username,  password: md5(password),  nickname: new Date().valueOf(),  signature: '暂无签名',  avatar: '/touxiang/touxiang.jpg'  }).save(function(error, user) {  // 生成一个cookie(userid: user._id), 并交给浏览器保存  // res.cookie('userid', user._id, { maxAge: 1000 * 60 * 60 * 24 })  req.session.userid = user._id  // 返回包含user的json数据  // const data = { username, _id: user._id } // 响应数据中不要携带password  res.send({ code: 0, msg: '恭喜你,注册成功！' })  })  } }) }) 检测登录状态 router.get('/isLogin', function(req, res) { const userid = req.session.userid if (!userid) {  return res.send({ code: 1, msg: '亲爱的游客,请您先登陆' }) } // 查询 UserModel.findOne({ _id: userid }, filter, function(err, user) {  // 如果没有, 返回错误提示  if (!user) {  // 清除浏览器保存的userid  delete req.session.userid  res.send({ code: 1, msg: '亲爱的游客,请您先登陆' })  } else {  // 如果有, 返回user  res.send({ code: 0, msg: '已登录', data: user })  } }) }) 登录的路由 router.post('/login', function(req, res) { const { username, password } = req.body UserModel.findOne({ username, password: md5(password) }, filter, function(  err,  user ) {  if (user) {  //登录成功  // res.cookie('userid', user._id, { maxAge: 1000 * 60 * 60 * 24 * 7 })  req.session.userid = user._id  res.send({ code: 0, msg: '恭喜你,登录成功!' })  } else {  //登录失败  res.send({ code: 1, msg: '用户名或密码不正确' })  } }) }) 上传头像 router.post('/avatar', (req, res, next) =&gt; { //上传文件只能通过这个插件接收 file是上传文件 fields是其他的 if (!fs.existsSync(userDirPath)) {  fs.mkdirSync(userDirPath) //创建目录 } var form = new formidable.IncomingForm() form.encoding = 'utf-8' //设置编辑 form.uploadDir = userDirPath //设置上传目录 form.keepExtensions = true //保留后缀 form.maxFieldsSize = 4 * 1024 * 1024 //文件大小 form.type = true form.parse(req, function(err, fields, files) {  if (Object.keys(files).length !== 0) {  var oldname = files.file.path  var newname = userDirPath + '/' + new Date().getTime() + '.jpg'  fs.rename(oldname, newname, err =&gt; {  if (err) {   res.send({ code: 1, msg: '上传失败' })   return  }  var userid = req.session.userid  UserModel.findByIdAndUpdate(   { _id: userid },   { avatar: newname.substring(6) },   function(error, oldUser) {   if (!oldUser) {   // 通知浏览器删除userid cookie   delete req.session.userid   // 返回返回一个提示信息   res.send({ code: 1, msg: '保存失败,登录已过期,请您先登陆' })   } else {   //上传成功，返回文件的相对路径   res.send({ code: 0, msg: '头像上传成功!' })   }   }  )  })  } }) }) 保存个人资料 router.post('/saveinfo', (req, res) =&gt; { // 从请求的session得到userid var userid = req.session.userid // 如果不存在, 直接返回一个提示信息 if (!userid) {  return res.send({ code: 1, msg: '登录已过期,请您先登陆' }) } // 存在, 根据userid更新对应的user文档数据 // 得到提交的用户数据 const user = req.body // 没有_id UserModel.findByIdAndUpdate({ _id: userid }, user, function(error, oldUser) {  if (!oldUser) {  // 通知浏览器删除userid  delete req.session.userid  // 返回返回一个提示信息  res.send({ code: 1, msg: '保存失败,登录已过期,请您先登陆' })  } else {  // 返回  res.send({ code: 0, msg: '保存成功' })  } }) }) 获取用户资料信息 router.get('/userinfo', function(req, res) { // 从请求的cookie得到userid var userid = req.session.userid // 如果不存在, 直接返回一个提示信息 if (!userid) {  return res.send({ code: 1, msg: '亲爱的游客,请您先登陆' }) } // 根据userid查询对应的user UserModel.findOne({ _id: userid }, filter, function(error, user) {  if (user) {  res.send({ code: 0, data: user })  } else {  delete req.session.userid  res.send({ code: 1, msg: '登录已过期,请您先登陆' })  } }) }) 发贴 router.post('/artical', (req, res, next) =&gt; { if (!fs.existsSync(articalDirPath)) {  fs.mkdirSync(articalDirPath) //创建目录 } var form = new formidable.IncomingForm() form.encoding = 'utf-8' //设置编辑 form.uploadDir = articalDirPath //设置上传目录 form.keepExtensions = true //保留后缀 form.maxFieldsSize = 20 * 1024 * 1024 //文件大小 form.multiples = true form.parse(req, function(err, fields, files) {  if (err) {  res.send({ code: 1, msg: '上传失败' })  return  }  var filesUrl = []  if (files.file) {  if (files.file.length &gt; 1) {  files.file.map((key, index) =&gt; {   var filePath = key.path   var fileExt = filePath.substring(filePath.lastIndexOf('.'))   //以当前时间戳对上传文件进行重命名   var fileName = new Date().getTime() + index + fileExt   var targetFile = path.join(articalDirPath, fileName)   //移动文件   fs.renameSync(filePath, targetFile)   // 文件的Url（相对路径）   filesUrl.push('/artical/' + fileName)  })  } else {  var filePath = files.file.path  var fileExt = filePath.substring(filePath.lastIndexOf('.'))  //以当前时间戳对上传文件进行重命名  var fileName = new Date().getTime() + fileExt  var targetFile = path.join(articalDirPath, fileName)  //移动文件  fs.renameSync(filePath, targetFile)  // 文件的Url（相对路径）  filesUrl.push('/artical/' + fileName)  }  }  var userid = req.session.userid  // 如果不存在, 直接返回一个提示信息  if (!userid) {  return res.send({ code: 1, msg: '亲爱的游客,请您先登陆' })  }  UserModel.findOne({ _id: userid }, filter, (error, user) =&gt; {  if (user) {  new ArticalModel({   cid: user._id,   author: user.nickname,   content: fields.info,   avatar: user.avatar,   imagefile: filesUrl,   date: new Date().getTime()  }).save(function(error, artical) {   res.send({ code: 0, msg: '发布成功!' })  })  } else {  delete req.session.userid  res.send({ code: 1, msg: '登录已过期,请您先登陆' })  }  }) }) }) 点赞 router.post('/praise', (req, res) =&gt; { const { commentid, userid } = req.body const commentId = mongoose.Types.ObjectId(commentid) // const userId = mongoose.Types.ObjectId(userid) ArticalModel.findByIdAndUpdate(  { _id: commentId },  { $addToSet: { praise: userid } },  function(err, artical) {  if (artical) {  res.send({ code: 0, msg: '点赞成功!' })  }  } ) }) 取消点赞 router.post('/nopraise', (req, res) =&gt; { const { commentid, userid } = req.body const commentId = mongoose.Types.ObjectId(commentid) // const userId = mongoose.Types.ObjectId(userid) ArticalModel.findByIdAndUpdate(  { _id: commentId },  { $pull: { praise: userid } },  function(err, artical) {  if (artical) {  res.send({ code: 0, msg: '取消成功!' })  }  } ) }) 评论点赞 router.post('/commentPraise', (req, res) =&gt; { const { commentid, userid } = req.body const commentId = mongoose.Types.ObjectId(commentid) // const userId = mongoose.Types.ObjectId(userid) CommentSchema.findByIdAndUpdate(  { _id: commentId },  { $addToSet: { praise: userid } },  function(err, artical) {  if (artical) {  res.send({ code: 0, msg: '点赞成功!' })  }  } ) }) 取消评论点赞 router.post('/noCommentPraise', (req, res) =&gt; { const { commentid, userid } = req.body const commentId = mongoose.Types.ObjectId(commentid) // const userId = mongoose.Types.ObjectId(userid) CommentSchema.findByIdAndUpdate(  { _id: commentId },  { $pull: { praise: userid } },  function(err, artical) {  if (artical) {  res.send({ code: 0, msg: '取消成功!' })  }  } ) }) 帖子信息 router.get('/articalinfo', function(req, res) { const userid = req.session.userid // 如果不存在, 直接返回一个提示信息 UserModel.findOne({ _id: userid }, (error, user) =&gt; {  if (user) {  ArticalModel.update(  { cid: user._id },  { author: user.nickname, avatar: user.avatar },  { multi: true },  function(err, raw) {   if (err) return err   console.log('raw', raw)  }  )  } }) // 如果不存在, 直接返回一个提示信息 ArticalModel.find({})  .sort({ date: -1 })  .exec(function(error, articalinfo) {  const data = articalinfo  res.send({ code: 0, data })  }) }) 搜索帖子 router.get('/search/articalinfo', function(req, res) { const search = req.query.search ArticalModel.find(function(error, articalinfo) {  const data = articalinfo.filter(item =&gt; item.content.search(search) !== -1)  res.send({ code: 0, data }) }) }) 评论 router.post('/comment', (req, res) =&gt; { const comment = req.body const articalId = mongoose.Types.ObjectId(comment.articalId) const userid = req.session.userid UserModel.findOne({ _id: userid }, (error, user) =&gt; {  if (user) {  new CommentSchema({  avatar: user.avatar,  author: user.nickname,  userid: userid,  createTime: new Date().getTime(),  content: comment.comment,  commentid: articalId  }).save(function(error, commentinfo) {  CommentSchema.find(   { commentid: commentinfo.commentid },   (error, comment) =&gt; {   if (comment) {   ArticalModel.findByIdAndUpdate(    { _id: commentinfo.commentid },    { commentNumber: comment.length },    function(err, oldArtical) {    }   )   }   }  )  res.send({ code: 0, msg: '评论成功!' })  })  } }) }) 回显评论 router.get('/replay_info', (req, res) =&gt; { const commentId = mongoose.Types.ObjectId(req.query.commentid) ReplaySchema.find({ replayid: commentId })  .sort({ createTime: -1 })  .exec((error, replay) =&gt; {  if (replay) {  res.send({ code: 0, data: replay })  }  }) }) 删除我的帖子 router.post('/deletmycomment', (req, res) =&gt; { const commentIdArr = req.body const idArr = commentIdArr.map(item =&gt; mongoose.Types.ObjectId(item)) ArticalModel.deleteMany({ _id: { $in: idArr } }, (err, orderInfo) =&gt; {  if (orderInfo) {  res.send({ code: 0, msg: '删除成功' })  } }) }) 删除订单 router.post('/deleteorder', (req, res) =&gt; { const orderIdObj = req.body const orderId = mongoose.Types.ObjectId(orderIdObj.orderid) OrderSchema.remove({ _id: orderId }, (err, orderInfo) =&gt; {  if (orderInfo) {  res.send({ code: 0, msg: '删除成功' })  } }) }) 退出登录 router.get('/loginout', function(req, res) { // 清除浏览器保存的userid的cookie delete req.session.userid // 返回数据 res.send({ code: 0, msg: '您已经成功退出登录!' }) }) 随机获取 casoursel router.get('/carousel/img', function(req, res) { const data = require('../data/carousel.json') let carousel = [] let indexArr = [] for (let i = 0; i &lt; 8; i++) {  let index = Math.floor(Math.random() * 8)  if (carousel.length &lt; 4) {  if (indexArr.indexOf(index) === -1) {  carousel.push(data[index])  indexArr.push(index)  }  } else {  res.send({ code: 0, data: carousel })  } } }) 获取 hot_spots 数据 router.get('/hotspots', function(req, res) { setTimeout(function() {  const data = require('../data/hot_spots.json')  res.send({ code: 0, data }) }, 300) }) ",
      "url"      : "http://localhost:4000/2020/02/26/node-backend-implement/",
      "keywords" : "Node"
    } ,
  
    {
      "title"    : "前端跨域通信的几种方式",
      "category" : "Javascript",
      "content": "jsonp、hash、postMessage、WebSocket jsonp &lt;script src=http://www.abc.com/?data=name&amp;callback=jsonp charset=utf-8&gt;&lt;/script&gt; // 通过callback的jsonp函数获取数据  &lt;script type=text/javascript&gt; function jsonp(data) {  console.log(data) }  &lt;/script&gt; hash  //场景是当前页面 A 通过iframe或frame嵌入了跨域的页面 B  // 在A中伪代码如下：  var B = document.getElementsByTagName('iframe');  B.src = B.src + '#' + 'data';  // 在B中的伪代码如下  window.onhashchange = function () {   var data = window.location.hash;  }; postMessage  // 窗口A(http:A.com)向跨域的窗口B(http:B.com)发送信息  Bwindow.postMessage('data', 'http://B.com');  // 在窗口B中监听  Awindow.addEventListener('message', function (event) {   console.log(event.origin);   console.log(event.source);   console.log(event.data);  }, false); WebSocket  var ws = new WebSocket('ws://echo.websocket.org');  ws.onopen = function (evt) {   console.log('Connection open ...');   ws.send('Hello WebSockets!');  };  ws.onmessage = function (evt) {   console.log('Received Message: ', evt.data);   ws.close();  };  ws.onclose = function (evt) {   console.log('Connection closed.');  }; CORS  // url（必选），options（可选）  fetch('/some/url/', {   method: 'get',  }).then(function (response) {  }).catch(function (err) {  // 出错了，等价于 then 的第二个参数，但这样更好用更直观  }); ",
      "url"      : "http://localhost:4000/2020/03/10/js-cross-domain/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "OOP的几种继承与使用",
      "category" : "Javascript",
      "content": "面向对象的基本用法 /**  * 类的声明  */  var Animal = function () {   this.name = 'Animal';  };  /**  * es6中class的声明  */  class Animal2 {   constructor () {   this.name = 'Animal2';   }  }  /**  * 实例化  */  console.log(new Animal(), new Animal2());  /**  * 借助构造函数实现继承  */  function Parent1 () {   this.name = 'parent1';  }  Parent1.prototype.say = function () {   console.log('parent1 say')  };  function Child1 () {   Parent1.call(this);   this.type = 'child1';  }  console.log(new Child1(), new Child1().say());  /**  * 借助原型链实现继承 (有缺点)  */  function Parent2 () {   this.name = 'parent2';   this.play = [1, 2, 3];  }  function Child2 () {   this.type = 'child2';  }  Child2.prototype = new Parent2();  var s1 = new Child2();  var s2 = new Child2();  console.log(s1.play, s2.play);  s1.play.push(4); // s1改变会影响s2  /**  * 组合方式 (可修复原型继承的缺点)  */  function Parent3 () {   this.name = 'parent3';   this.play = [1, 2, 3];  }  function Child3 () {   Parent3.call(this);   this.type = 'child3';  }  Child3.prototype = new Parent3();  var s3 = new Child3();  var s4 = new Child3();  s3.play.push(4);  console.log(s3.play, s4.play);  /**  * 组合继承的优化1  * @type {String}  */  function Parent4 () {   this.name = 'parent4';   this.play = [1, 2, 3];  }  function Child4 () {   Parent4.call(this);   this.type = 'child4';  }  Child4.prototype = Parent4.prototype;  var s5 = new Child4();  var s6 = new Child4();  console.log(s5, s6);  console.log(s5 instanceof Child4, s5 instanceof Parent4);  console.log(s5.constructor);  /**  * 组合继承的优化2 Object.create  */  function Parent5 () {   this.name = 'parent5';   this.play = [1, 2, 3];  }  function Child5 () {   Parent5.call(this);   this.type = 'child5';  }  Child5.prototype = Object.create(Parent5.prototype); ",
      "url"      : "http://localhost:4000/2020/03/10/js-oop/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "关于闭包的理解",
      "category" : "Javascript",
      "content": "闭包应用场景  闭包函数定义 声明在一个函数中的函数 闭包定义 内部函数总是可以访问其所在的外部函数中声明的参数和变量,即使在其外部函数被返回了之后 特点  让外部访问函数内部变量成为可能； 局部变量会常驻在内存中； 可以避免使用全局变量，防止全局变量污染； 会造成内存泄漏(内存空间长期被占用，而不被释放) Example 1 function funA() { var a = 10; // funA的活动对象之中; return function() {  //匿名函数的活动对象;  alert(a); }; } var b = funA(); b(); //10 Example 2 function outerFn() { var i = 0; function innerFn() {  i++;  console.log(i); } return innerFn; } var inner = outerFn(); //每次外部函数执行的时候，外部函数的地址不同，都会重新创建一个新的地址 inner(); inner(); inner(); var inner2 = outerFn(); inner2(); inner2(); inner2(); //1 2 3 1 2 3 Example 3 var i = 0; function outerFn() { function innnerFn() {  i++;  console.log(i); } return innnerFn; } var inner1 = outerFn(); var inner2 = outerFn(); inner1(); inner2(); inner1(); inner2(); //1 2 3 4 Example 4 function fn() { var a = 3; return function() {  return ++a; }; } alert(fn()()); //4 alert(fn()()); //4 Example 5 function outerFn() { var i = 0; function innnerFn() {  i++;  console.log(i); } return innnerFn; } var inner1 = outerFn(); var inner2 = outerFn(); inner1(); inner2(); inner1(); inner2(); //1 1 2 2 Example 6 function outerFn() { var i = 0; function innnerFn() {  i++;  console.log(i); } return innnerFn; } var inner1 = outerFn(); var inner2 = outerFn(); inner1(); inner2(); inner1(); inner2(); //1 1 2 2 Example 7 (function() { var m = 0; function getM() {  return m; } function seta(val) {  m = val; } window.g = getM; window.f = seta; })(); f(100); console.info(g()); //100 闭包找到的是同一地址中父级函数中对应变量最终的值 Example 8 function a() { var i = 0; function b() {  alert(++i); } return b; } var c = a(); c(); //1 c(); //2 Example 9 var add = function(x) { var sum = 1; var tmp = function(x) {  sum = sum + x;  return tmp; }; tmp.toString = function() {  return sum; }; return tmp; }; alert(add(1)(2)(3)); //6 Example 10 var lis = document.getElementsByTagName(li); for (var i = 0; i &lt; lis.length; i++) { (function(i) {  lis[i].onclick = function() {  console.log(i);  }; })(i); //事件处理函数中闭包的写法 } Example 11 function m1() { var x = 1; return function() {  console.log(++x); }; } m1()(); //2 m1()(); //2 m1()(); //2 var m2 = m1(); m2(); //2 m2(); //3 m2(); //4 Example 12 var fn=(function(){ var i=10; function fn(){  console.log(++i); } return fn; })() fn(); //11 fn(); //12 Example 13 function love1(){ var num = 223; var me1 = function() {  console.log(num); } num++; return me1; } var loveme1 = love1(); loveme1(); //输出224 Example 14 function fun(n,o) {  console.log(o);  return {  fun:function(m) {   return fun(m,n);  }  }; } var a = fun(0); //undefined a.fun(1); //0 a.fun(2); //0 a.fun(3); //0 var b = fun(0).fun(1).fun(2).fun(3); //undefined 0 1 2 var c = fun(0).fun(1); c.fun(2); c.fun(3); //undefined 0 1 1 Example 15 function fn(){ var arr = []; for(var i = 0;i &lt; 5;i ++){  t arr[i] = function(){  t t return i;  t } } return arr; } var list = fn(); for(var i = 0,len = list.length;i &lt; len ; i ++){ console.log(list[i]()); } //5 5 5 5 5 Example 16 function fn(){ var arr = []; for(var i = 0;i &lt; 5;i ++){  tarr[i] = (function(i){  t treturn function (){  t t treturn i;  t t};  t})(i); } return arr; } var list = fn(); for(var i = 0,len = list.length;i &lt; len ; i ++){ console.log(list[i]()); } //0 1 2 3 4 ",
      "url"      : "http://localhost:4000/2020/04/10/js-closure-scene/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "js原型链",
      "category" : "Javascript",
      "content": "原型链  在任意对象和Object.prototype之间，存在着一条以非标准属性__proto__进行连接的链，那我们管这条链叫做原型链 原型每个函数都有一个prototype属性,这个属性指向的就是原型对象. 实例有一个__proto__指向它构造函数的原型对象. 原型链当调用一个对象的属性时，如果自身对象未找到，便会去对象的__proto__属性去查找，找到原型，原型也拥有__proto__属性，所以对继续向上查找，一直找到Object.prototype.proto === null 特点原型对象上的方法是被不同实例共有的, 当我们修改原型时，与之相关的对象也会继承这一改变。  // 第一种方式：字面量  var o1 = {name: 'o1'};  var o2 = new Object({name: 'o2'});  // 第二种方式：构造函数  var M = function (name) { this.name = name; };  var o3 = new M('o3');   // 第三种方式：Object.create  var p = {name:'p'}  var o4 = object.create(p)  // new 运算符的工作原理  var new1 = function(func) {  var o = Object.create(func.prototype)  var k = func.call(o)  if(typeof k === 'object') {   return k  }  else {   return o  }  } ",
      "url"      : "http://localhost:4000/2020/05/10/js-prototype-chain/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "BFC布局",
      "category" : "HTML5",
      "content": "BFC 块格式化上下文 主要由以下之一创建 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 场景  &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;  &lt;meta charset=utf-8&gt;  &lt;title&gt;BFC&lt;/title&gt;  &lt;style media=screen&gt;  html *{  margin: 0;  padding: 0;  }  &lt;/style&gt; &lt;/head&gt; &lt;body&gt;  &lt;section class=box id=sec&gt;  &lt;style media=screen&gt;   #sec{   background: #f00;   overflow: hidden;/* 加入overflow形成BFC */   }   .child{   height: 100px;   margin-top: 10px;   background: yellow   }  &lt;/style&gt;  &lt;article class=child&gt;&lt;/article&gt;  &lt;/section&gt;  &lt;!-- BFC垂直方向边距重叠 --&gt;  &lt;section id=margin&gt;  &lt;style&gt;  #margin{   background: pink;   overflow: hidden;  }  #margin p{   margin: 5px auto 25px;   background: red;  }  &lt;/style&gt;  &lt;p&gt;1&lt;/p&gt;  &lt;div style=overflow:hidden&gt;  &lt;p&gt;2&lt;/p&gt;  &lt;/div&gt;  &lt;p&gt;3&lt;/p&gt;  &lt;/section&gt;  &lt;!-- BFC不与float重叠 --&gt;  &lt;section id=layout&gt;  &lt;style media=screen&gt;   #layout{   background: red;   }   #layout .left{   float: left;   width: 100px;   height: 100px;   background: pink;   }   #layout .right{   height: 110px;   background: #ccc;   overflow: auto;   }  &lt;/style&gt;  &lt;div class=left&gt;&lt;/div&gt;  &lt;div class=right&gt;&lt;/div&gt;  &lt;/section&gt;  &lt;!-- BFC子元素即使是float也会参与计算 --&gt;  &lt;section id=float&gt;  &lt;style media=screen&gt;   #float{   background: red;   overflow: auto;   /*float: left;*/   }   #float .float{   float: left;   font-size: 30px;   }  &lt;/style&gt;  &lt;div class=float&gt;我是浮动元素&lt;/div&gt;  &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; ",
      "url"      : "http://localhost:4000/2020/05/12/bfc-layout/",
      "keywords" : "HTML5"
    } ,
  
    {
      "title"    : "js自定义事件",
      "category" : "Javascript",
      "content": "自定义js代码编写  // 方式1  const eve = new Event('test');  document.addEventListener('test', function () {  console.log('test dispatch');  });  document.dispatchEvent(eve); // 方式2  const customEvent = new CustomEvent('test')  document.addEventListener('test', function () {  console.log('test dispatch');  });  document.dispatchEvent(customEvent); // 方式3  // 创建事件对象：  const ev = document.createEvent('MouseEvents') //HTMLEvents MouseEvents UIEvents  // 初始化事件对象：  ev.initEvent('click', false, false, data); // data是数据  // 分派事件：  document.dispatchEvent(ev)  // 监听事件：  document.addEventListener('click', e =&gt; {  console.log(e.data)  }) // 方式4 type =&gt; MouseEvents, MutationEvents, HTMLEvents  document.querySelector('#id').addEventListener(type, function () {  console.log('自定义事件被触发了');  }); ",
      "url"      : "http://localhost:4000/2020/05/12/js-custom-events/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "js运行机制",
      "category" : "Javascript",
      "content": "单线程 JavaScript语言的一大特点就是单线程,同一个时间只能做同一件事 核心理解  首先判断JS是同步还是异步,同步就进入主线程,异步就进入event table 异步任务在event table中注册函数,当满足触发条件后,被推入event queue 同步任务进入主线程后一直执行,直到主线程空闲时,才会去event queue中查看是否有可执行的异步任务,如果有就推入主线程中   一般的JavaScript代码（同步）的属于宏任务，定时器相关的异步代码，包括setTimeOut、setInterval等也属于宏任务，promise、 process.nextTick属于微任务；   同步的代码会按照执行顺序顺序执行，遇到异步代码的时候，属于宏任务的放到宏队列，微任务放到微队列，其中promise需要resolve或者reject才会执行then或者catch里面的内容，其他的放到队列的属于回调函数的内容。   执行顺序是宏任务-微任务-宏任务……，因为整个脚本就是一个大的宏任务，所以当里面宏任务和微任务同时放入队列，会先执行玩微任务再执行宏任务；前提是主线程代码执行完毕，如果存在嵌套关系，则会先执行完该任务再执行下一个任务，如果问题复杂建议通过画图来理清楚 参考文章 JavaScript 运行机制详解：再谈Event Loop http://www.ruanyifeng.com/blog/2014/10/event-loop.html 深入理解JS引擎的执行机制 https://segmentfault.com/a/1190000012806637 Tasks, microtasks, queues and schedules https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/?utm_source=html5weekly ",
      "url"      : "http://localhost:4000/2020/05/12/js-operating-mechanism/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "简单记录下JavaScript设计模式",
      "category" : "设计模式",
      "content": "单例模式 单例模式保证类只有一个实例，并提供一个访问它的全局访问点 Example: function getSingle(fn){  let result return function (){  return result || (result=fn.apply(this,arguments))  } } 策略模式 解决一个问题的多个方法，将每种方法独立封装起来，相互可以替换 一个基于策略模式的程序至少由两部分组成，一个是一组策略类，策略类封装了具体的算法，并负责具体的计算过程，一个是环境类，环境类接受客户的请求，随后把请求委托给某个策略类 策略模式的一个使用场景：表单验证，将不同验证规则封装成一组策略，避免了多重条件判断语句，一句经典的话: 在函数作为一等对象的语言中，策略模式是隐性的，策略就是值为函数的变量 Example: const S = (salary)=&gt;{  return salary * 4  }  const A = (salary)=&gt;{  return salary * 3  }  const B = (salary)=&gt;{  return salary * 2  }  const calculate = (fun,salary)=&gt;{  return fun(salary)  }  calculate(S,1000) 代理模式 代理模式为一个对象提供一个代用品或占位符，以便控制对它的访问 不直接和本体进行交互，而是在中间加入一层代理，代理来处理一些不需要本体做的操作 var myImage=function(){  var imgNode=document.createElement('img')  document.body.appendChild(imgNode)  return {  setImg(src){   imgNode.src=src  }  } } var proxyImg=function(){  var img =new Image()  img.onload=function(){  myImage.setSrc(this.src)  }  return {  setImg(src){   myImage.setSrc(‘loading.png’)   img.src=src   }  } } 观察者和发布订阅模式 观察者和发布、订阅模式使程序的两部分不必紧密耦合在一起，而是通过通知的方式来通信 观察者模式 一个对象维持一系列依赖于它的对象，当对象状态发生改变时主动通知这些依赖对象 class Subject{  constructor(){   this.observers=[]  }  add(observer){   this.observers.push(observer)  }  notify(data){   for(let observer of this.observers){    observer.update(data)   }  }  }  class Observer{  update(){  }  } 观察者模式的缺点是对象必须自己维护一个观察者列表，当对象状态有更新时，直接调用其他对象的方法，所以，在使用中，我们一般采用一种变形方式，即发布订阅模式 发布订阅模式 该模式在主题和观察者之间加入一层管道，使得主题和观察者不直接交互，发布者将内容发布到管道，订阅者订阅管道里的内容，目的是避免订阅者和发布者之间产生依赖关系 class Pubsub{  constuctor(){   this.pubsub={}   this.subId=-1  }  publish(topic,data){   if(!this.pubsub[topic]) return   const subs=this.pubsub[topic]   const len=subs.length   while(len--){    subs[len].update(topic,data)   }  }  /**  * topic {string}  * update {function}  */  subscribe(topic,update){   !this.pubsub[topic] &amp;&amp; (this.pubsub[topic]=[])   this.subId++   this.pubsub[topic].push({    token:this.subId,    update   })  }  unsubscribe(token){   for(let topic in this.pubsub){    if(this.pubsub.hasOwnProperty(topic)){    const current=this.pubsub[topic]    for(let i=0,j=current.length;i&lt;j;i++){     if(current[i].token==token){      current.splice(i,1)      return token     }    }    }   }   return this  } } 命令模式 命令模式的命令指的是一个执行某些特定事情的指令 命令模式最常见的使用场景是：有时候需要向某些对象发送请求，但是不知道请求的接受者是谁，也不知道被请求的操作是什么。此时希望用一种松耦合的方式来设计程序，是使得请求发送者和接受者消除彼此之间的耦合关系 几大原则 单一职责原则SRP 一个类只负责一个功能领域的相应职责，即就一个类而言，应该只有一个引起它变化的原因。 单一职责原则是实现高内聚、低耦合的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 开闭原则OCP 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。 在开闭原则的定义中，软件实体可以指一个软件模块、一个由多个类组成的局部结构或一个独立的类 里氏替换原则LSP 所有引用父类的地方必须能透明地使用其子类的对象。 里氏替换原则告诉我们：在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象，它不一定能够使用基类对象 依赖倒置原则DIP 抽象不应该依赖于细节，细节应当依赖于抽象，要针对接口编程，而不是针对实现编程。 接口隔离原则ISP 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。 迪米特法则LoD 一个软件实体应当尽可能少地与其他实体发生相互作用。 如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 ",
      "url"      : "http://localhost:4000/2020/06/23/js-design-pattern/",
      "keywords" : "设计模式"
    } ,
  
    {
      "title"    : "百度地图API的简单使用",
      "category" : "API",
      "content": "首先编写HTML页面的基础代码,并引入API文件 &lt;!DOCTYPE html&gt; &lt;html lang=en&gt; &lt;head&gt;  &lt;meta charset=utf-8&gt;  &lt;meta name=viewport content=width=device-width, initial-scale=1, shrink-to-fit=no&gt;  &lt;title&gt;BMap&lt;/title&gt;  &lt;!-- 百度地图API js文件 ak=密钥 --&gt;  &lt;script type=text/javascript src=http://api.map.baidu.com/api?v=2.0&amp;ak=Z6VLb33wYXOcBcWtpVMjPvbU0DpUdQup&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;  &lt;div id=root&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 然后初始化地图等一些逻辑操作 1.话不多说，直接上代码 var map = {} // 列表请求 https://www.easy-mock.com模拟数据  var requestList = ()=&gt;{  axios.ajax({   url:'https://www.easy-mock.com/mock/5a7278e28d0c633b9c4adbd7/api/map/bike_list',   data:{    params:params   }  }).then((res)=&gt;{   if(res){    renderMap(res.result);   }  })  }  // 渲染地图  function renderMap(res) {  var list = res.route_list;  map = new window.BMap.Map(root, {enableMapClick: false});  var gps1 = list[0].split(',');  var startPoint = new window.BMap.Point(gps1[0], gps1[1]);  var gps2 = list[list.length - 1].split(',');  var endPoint = new window.BMap.Point(gps2[0], gps2[1]);  map.centerAndZoom(endPoint, 11);  // map.clearOverlays();  //添加起始图标  var startPointIcon = new window.BMap.Icon(/assets/start_point.png, new window.BMap.Size(36, 42), {   imageSize: new window.BMap.Size(36, 42),   anchor: new window.BMap.Size(18, 42)  });   var bikeMarkerStart = new window.BMap.Marker(startPoint, { icon: startPointIcon });  map.addOverlay(bikeMarkerStart);  var endPointIcon = new window.BMap.Icon(/assets/end_point.png, new window.BMap.Size(36, 42), {   imageSize: new window.BMap.Size(36, 42),   anchor: new window.BMap.Size(18, 42)  });  var bikeMarkerEnd = new window.BMap.Marker(endPoint, { icon: endPointIcon });  map.addOverlay(bikeMarkerEnd);  var routeList = [];  list.forEach((item)=&gt;{   var p = item.split(,);   var point = new window.BMap.Point(p[0], p[1]);   routeList.push(point);  })  // 行驶路线  var polyLine = new window.BMap.Polyline(routeList, {   strokeColor: #ef4136,   strokeWeight: 3,   strokeOpacity: 1  });  map.addOverlay(polyLine);  // 服务区路线  var serviceList = res.service_list;  var servicePointist = [];  serviceList.forEach((item) =&gt; {   var point = new window.BMap.Point(item.lon, item.lat);   servicePointist.push(point);  })  // 画线  var polyServiceLine = new window.BMap.Polyline(servicePointist, {   strokeColor: #ef4136,   strokeWeight: 3,   strokeOpacity: 1  });  map.addOverlay(polyServiceLine);  // 添加地图中的自行车  var bikeList = res.bike_list;  var bikeIcon = new window.BMap.Icon(/assets/bike.jpg, new window.BMap.Size(36, 42), {   imageSize: new window.BMap.Size(36, 42),   anchor: new window.BMap.Size(18, 42)  });  bikeList.forEach((item) =&gt; {   var p = item.split(,);   var point = new window.BMap.Point(p[0], p[1]);   var bikeMarker = new window.BMap.Marker(point, { icon: bikeIcon });   map.addOverlay(bikeMarker);  })   // 添加地图控件  addMapControl();  }; // 添加地图控件  function addMapControl() {  var map = map;  // 左上角，添加比例尺  var top_right_control = new window.BMap.ScaleControl({anchor: window.BMAP_ANCHOR_TOP_RIGHT});  var top_right_navigation = new window.BMap.NavigationControl({anchor: window.BMAP_ANCHOR_TOP_RIGHT});  //添加控件和比例尺  map.addControl(top_right_control);  map.addControl(top_right_navigation);  map.enableScrollWheelZoom(true);  // legend.addLegend(map);  }; ",
      "url"      : "http://localhost:4000/2020/09/13/api-baidu-map/",
      "keywords" : "API"
    } ,
  
    {
      "title"    : "简单记录下react中使用富文本",
      "category" : "React",
      "content": "在react项目中使用富文本编辑器 首先，先安装 draftjs-to-html、react-draft-wysiwyg yarn add draftjs-to-html react-draft-wysiwyg 话不多说，然后直接上代码：(这里使用的是antd组件进行组合使用) import React from 'react' import { Button, Card, Modal } from 'antd' import { Editor } from 'react-draft-wysiwyg' import 'react-draft-wysiwyg/dist/react-draft-wysiwyg.css' import draftjs from 'draftjs-to-html' export default class RichText extends React.Component { state = {  showRichText: false,  editorContent: '',   editorState: '',  };  // 清空富文本内容  handleClearContent = () =&gt; {  this.setState({   editorState: ''  })  }  // 展示富文本内容  handleGetText = () =&gt; {  this.setState({   showRichText: true  })  }  // 监听展示内容变化  onEditorChange = (editorContent) =&gt; {  this.setState({   editorContent,  });  };  // 监听富文本编辑器内容的变化  onEditorStateChange = (editorState) =&gt; {  this.setState({   editorState  });  }; render() {  const { editorContent, editorState } = this.state;  return (   &lt;div&gt;    &lt;Card style=&gt;    &lt;Button type=primary onClick={this.handleClearContent}&gt;清空内容&lt;/Button&gt;    &lt;Button type=primary onClick={this.handleGetText}&gt;获取HTML文本&lt;/Button&gt;    &lt;/Card&gt;    &lt;Card title=富文本编辑器&gt;    &lt;Editor     editorState={editorState}     onContentStateChange={this.onEditorChange}     onEditorStateChange={this.onEditorStateChange}    /&gt;    &lt;/Card&gt;    &lt;Modal    title=富文本    visible={this.state.showRichText}    onCancel={() =&gt; {     this.setState({      showRichText: false     })    }}    footer={null}    &gt;    {draftjs(this.state.editorContent)}    &lt;/Modal&gt;   &lt;/div&gt;  );  } } 该api有趣，后续继续更新。。。 ",
      "url"      : "http://localhost:4000/2020/09/13/api-react-draft-wysiwyg/",
      "keywords" : "API, React"
    } ,
  
    {
      "title"    : "js数组方法的简单实现",
      "category" : "Javascript",
      "content": "前言 开发中经常会遇到对数据的操作，这难免会有用到数组的方法，闲来无事,整理一下es6各大数组方法的原理实现（自己实现的，可能跟源码有偏差） forEach的实现 Array.prototype.myforEach = function (callback) {  for (let i = 0; i &lt; this.length; i++) {  callback(this[i])  } } map的实现 Array.prototype.mymap = function (callback) {  const result = []  this.myforEach(item =&gt; {  result.push(callback(item))  })  return result } filter的实现 Array.prototype.myfilter = function (callback) {  const result = []  this.myforEach(item =&gt; {  if (callback(item)) {   result.push(item)  }  })  return result } find的实现 Array.prototype.myfind = function (callback) {  let result = undefined  this.myforEach(item =&gt; {  if (callback(item)) {   result = item  }  })  return result } every的实现 Array.prototype.myevery = function (callback) {  let status = true  this.myforEach(item =&gt; {  if (!callback(item)) {   status = false  }  })  return status } some的实现 Array.prototype.mysome = function (callback) {  let status = false  this.myforEach(item =&gt; {  if (callback(item)) {   status = true  }  })  return status } // 初始化实例 const arr = [1, 2, 3, 4] // 测试map // console.log(arr.mymap(item =&gt; item + 1)) // 测试filter // console.log(arr.myfilter(item =&gt; [1, 2, 4].includes(item))) // 测试find // console.log(arr.myfind(item =&gt; item === 5)) // 测试every // console.log(arr.myevery(item =&gt; item === 4)) // 测试some console.log(arr.mysome(item =&gt; item === 4)) ",
      "url"      : "http://localhost:4000/2020/10/06/js-array-handle/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "js数组去重",
      "category" : "Javascript",
      "content": "数组对象去重 /** * 数组对象去重 * @param {*} array 要去重的数组 * @param {*} key 要比较的key字段 */ const repeatArrayWithObj = (array = [], key) =&gt; {  const repeatObj = {}, newArray = [];  for(let i = 0;i &lt; array.length; i++) {  if (repeatObj[array[i].userName] &gt;= 0) {   continue;  }  repeatObj[array[i][key]] = i;  newArray.push(array[i]);  }  return newArray; } 单个字符串或者数字内容去重 /** * 单个字符串或者数字内容去重 * @param {*} array 要去重的数组 */ const repeatArrayWithSingle = (array = []) =&gt; { return Array.from(new Set(array)) } ",
      "url"      : "http://localhost:4000/2020/10/06/js-array-unrepeat/",
      "keywords" : "Javascript"
    } ,
  
    {
      "title"    : "js将平坦对象转为对象",
      "category" : "Javascript",
      "content": "需求 给定一个平坦字典对象,其键是点分隔的。 例如,{‘A’:1,’B.A’:2,’B.B’:3,’CC.D.E’:4,’CC.D.F’:5}。 实现一个将其转换为嵌套字典对象的函数。 在上述情况下,嵌套版本如下: {  A: 1,  B: {  A: 2,  B: 3  },  CC: {  D: {   E: 4,   F: 5  }  } } 思路  先遍历平坦对象拿到key 处理key,将key切割为对象属性数组,反转属性,深度遍历,然后进行对象逐层包裹,形成对象 将每一个key所形成的对象进行合并,合并时需进行深度遍历,有相同的属性,就进行覆盖,不同的属性就进行添加 使用递归进行深度遍历,逐层合并 js实现  // 转化对象  const transferObj = obj =&gt; {  let values = {};  for (const key in obj) {   if (key.indexOf('.') &gt; -1) {    let temp = {}    // 将属性字符串拆分翻转一下深度遍历    key.split('.').reverse().forEach((item, index) =&gt; {    if (index === 0) {     temp[item] = obj[key]    } else {     let objValue = {}     objValue[item] = temp     temp = objValue    }    })    // 将每一个属性进行深度合并    values = objMerge(values, temp)   } else {    values[key] = obj[key]   }  }  return values  }  // 深度合并  const objMerge = (...obj) =&gt; {  let res = {};  // 对象合并  const combine = opt =&gt; {   for (const key in opt) {    if (opt.hasOwnProperty(key)) {    //下面是深拷贝与浅拷贝的区别，用到了递归的思想    if (opt[key].constructor == Object) {     res[key] = objMerge(res[key], opt[key]);    } else {     res[key] = opt[key];    }    }   }  }  // ...obj 将形参解构形成数组对象  for (let i = 0; i &lt; obj.length; i++) {   combine(obj[i]);  }  return res;  }  // 测试  const example = { 'a': 1, 'b.c': 2, 'b.c.f': 3, 'b.c.r': 4 }  console.log(transferObj(example)) // {a: 1,b:{c: {f: 3, r: 4}}} ",
      "url"      : "http://localhost:4000/2020/10/12/js-obj-transfer/",
      "keywords" : "Javascript, ES6"
    } ,
  
    {
      "title"    : "BOM日常",
      "category" : "Javascript",
      "content": "前言 在开发中经常会遇到些许冷门的一些对BOM操作，下面记录下自己遇到的一些操作 页面复制功能 这里写一个简单的api const copy = text =&gt; {  // 创建dom节点  const oInput = document.createElement('input');  oInput.value = text;  document.body.appendChild(oInput);  // 选择对象  oInput.select();  // 执行浏览器复制命令  document.execCommand('Copy')  oInput.style.display = 'none';  document.body.removeChild(oInput); } ",
      "url"      : "http://localhost:4000/2020/10/28/js-bom-handle/",
      "keywords" : "Javascript, ES6"
    } ,
  
    {
      "title"    : "获取部分主流浏览器类型",
      "category" : "Javascript",
      "content": "前言 平时开发时难免会遇到一些浏览器兼容问题，以下是获取部分浏览器类型的总结 const getDeviceName = () =&gt; {  let browserType = '未知浏览器';  if (ifUserAgentExit('Chrome') &amp;&amp; ifUserAgentExit('Safari')) {  if (ifUserAgentExit('OPR')) {   browserType = 'Opera浏览器';  } else if (ifUserAgentExit('360EE')) {   browserType = '360极速浏览器';  } else if (ifUserAgentExit('360SE')) {   browserType = '360安全浏览器';  } else if (ifUserAgentExit('Edge')) {   browserType = 'Microsoft Edge浏览器';  } else {   browserType = 'Chrome浏览器';  }  } else if (ifUserAgentExit('Firefox')) {  browserType = 'Firefox浏览器';  } else if (ifUserAgentExit('Mac')) {  browserType = 'Safari浏览器';  } else if ((ifUserAgentExit('compatible') &amp;&amp; ifUserAgentExit('msie')) || (ifUserAgentExit('trident') &amp;&amp; ifUserAgentExit('rv:11.0'))) { //IE11及以下  browserType = 'IE浏览器';  }  return browserType; } const ifUserAgentExit = str =&gt; {  let userAgent = navigator.userAgent;  return userAgent.indexOf(str) &gt; -1 ? true:false; } ",
      "url"      : "http://localhost:4000/2020/10/28/js-browser-type/",
      "keywords" : "Javascript, ES6"
    } ,
  
    {
      "title"    : "Javascript小工具集锦",
      "category" : "Javascript",
      "content": "前言 开发中难免会遇到一些处理数据的问题，下面是本人记录的一些日常api 数字转为千分位字符 /** * @param {Number} num * @param {Number} point 保留几位小数，默认2位 */ const parseToThousandth = (num, point = 2) =&gt; {  let [sInt, sFloat] = (Number.isInteger(num) ? `${num}` : num.toFixed(point)).split('.');  sInt = sInt.replace(/  d(?=(  d{3})+$)/g, '$&amp;,');  return sFloat ? `${sInt}.${sFloat}` : `${sInt}`; }; 多层数组扁平化 const flatten = (arr) =&gt; {  return arr.reduce((result, item) =&gt; {  return result.concat(Array.isArray(item) ? flatten(item) : item);  }, []); }; 下划线转换驼峰#驼峰转换下划线 const toHump = (str) =&gt; {  return str.replace(/_(  w)/g, (all, letter) =&gt; letter.toUpperCase()); }; const toLine = (str) =&gt; {  return str.replace(/([A-Z])/g, '_$1')  .toLowerCase(); }; ",
      "url"      : "http://localhost:4000/2020/10/28/js-tool-show/",
      "keywords" : "Javascript, ES6"
    } ,
  
    {
      "title"    : "百度翻译api",
      "category" : "",
      "content": "百度翻译api的使用 baiduTranslate=()=&gt;{  const option = {   appid: '20190216000267610', //申请的appid   key: 'avc5ndaA3W9TK7E1oHPO', //   from: 'auto',   to: 'en', // 翻译后的语言  };  const salt = new Date().getTime();  let content = null; // 需要翻译的内容  content = content.replace(/  /:  d{3}/g, ' ');  content = content.replace(/&lt;br   /&gt;/g, '  ');  const str1 = option.appid + content + salt + option.key;  const sign = MD5(str1);  const formData = new FormData();  formData.append('q', content);  formData.append('appid', option.appid);  formData.append('salt', salt);  formData.append('from', option.from);  formData.append('to', option.to);  formData.append('sign', sign);  $.ajax({   url: 'https://fanyi-api.baidu.com/api/trans/vip/translate',   type: 'get',   dataType: 'jsonp',   data: {    q: content,    appid: option.appid,    salt,    from: option.from,    to: option.to,    sign,   },   success: (data) =&gt; {    if (data &amp;&amp; data.trans_result &amp;&amp; data.trans_result.length) {    const transResult = data.trans_result.map(v =&gt; `${v.dst}&lt;br /&gt;`).join('');    }   },  });  } ",
      "url"      : "http://localhost:4000/2021/01/30/api-baidu-transfer/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "promise的实现",
      "category" : "",
      "content": "实现原理 Promise也是回调函数，只不过是把回调封装在了内部，使用上一直通过then方法的链式调用，使得多层的回调嵌套看起来变成了同一层的，书写上以及理解上会更直观和简洁一些。 一、基础版本 // 实现 class Promise{  callbacks = [];  constructor(fn) {  fn(this._resolve.bind(this));  }  then(onFulfilled) {  this.callbacks.push(onFulfilled);  return this; // 可进行链式调用  }  _resove(value) {  this.callbacks.forEach(fn =&gt; fn(value))  } } // 应用 let p = new Promise(resolve =&gt; {  setTimeout(() =&gt; {  resolve('done');  },5000) }).then(res =&gt; {  console.log(res,'res'); }) 二、增加状态 //实现+链式调用+延迟机制+状态 class Promise {  callbacks = [];  state = 'pending';//增加状态  value = null;//保存结果  constructor(fn) {  fn(this._resolve.bind(this));  }  then(onFulfilled) {  if (this.state === 'pending') {//在resolve之前，跟之前逻辑一样，添加到callbacks中   this.callbacks.push(onFulfilled);  } else {//在resolve之后，直接执行回调，返回结果了   onFulfilled(this.value);  }  return this;  }  _resolve(value) {  this.state = 'fulfilled';//改变状态  this.value = value;//保存结果  this.callbacks.forEach(fn =&gt; fn(value));  } } 三、原型链实现 function Promise(exector) {  let _this = this;  let status = pending, value = undefined, reason = undefined;  function resolve(value) {  if (status === pending) {   _this.value = value;   _this.status = resolve;  }  }  function reject(value) {  if (status == pending) {   _this.value = value;   _this.status = reject  }  }  try {  exector(resolve, reject)  } catch (e) {  reject(e)  } } Promise.prototype.then = function (resolve, reject) {  let _this = this;  if (this.status === resolve) {  resolve(_this.value)  }  if (this.status == reject) {  reject(_this.reason)  } } let promise = new Promise((reject, resolve) =&gt; {  resolve(return resolve) }); promise.then(data =&gt; { }, err =&gt; { }) ",
      "url"      : "http://localhost:4000/2021/03/30/js-promise-implement/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "书籍是知识的海洋!",
      "category" : "",
      "content": " 2019 书单 2020 书单 2021 书单 2019 书单  《JavaScript 高级程序设计》（红宝书3） 网盘链接:https://pan.baidu.com/s/193R17yu0qcsggWj8UnBq3A 密码:9mw9  《你不知道的 JavaScript》 网盘链接:https://pan.baidu.com/s/1L8wxhlM0SSUfstQja_v68w 密码:c6l6 ===本书内容，难点相关学习  【ES6 学习笔记之】Number.EPSILON (In 40Pages)  《学习 JavaScript 数据结构与算法》 网盘链接:https://pan.baidu.com/s/19OjSA9FQDIpXXTgZ7dWPDw 密码:9cy1 2020 书单  《深入 React 技术栈》 《精通Javascript》 — JQuery之父 著 《JavaScript语言精粹（修订版）》 《高性能JavaScript编程》 《JavaScript Web应用开发》 2021 书单 专业书籍 《JavaScript 高级程序设计》（红宝书4） 其他书籍  《人设》 《我不喜欢这个世界，我只喜欢你》 《成为我自己》 ",
      "url"      : "http://localhost:4000/books/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "知识在于不断积累，查漏补缺实乃王道！",
      "category" : "",
      "content": " 2019 面试题   网上面试题  react 面试题汇总  es6 面试题汇总   2019 面试题 网上面试题  一卷 1、快速排序和冒泡排序 2、BFC 概念，BFC 怎样形成的 3、AMD 和 CMD 的概念 4、import 和 export 5、rem 的适配方案 6、git 或 svn 常用命令 7、闭包，构造函数，继承 8、flex 布局和 fle 兼容性问题 9、浏览器从 url 输入到渲染成页面经历了哪些过程 10、ES6 语法 11、grunt 和 gulp 原理及应用 12、本地 localstorage 和 session 的区别 13、nodejs 是干什么用的 14、http https 的概念，为什么 http 不能访问 https 15、npm 包管理机制，package.json 16、html 语义化和 H5 标签 17、页面性能优化 18、前端 SEO 19、IE8 的兼容问题，hack 20、在改变 url 时页面不刷新的办法 二卷 JavaScript 基础 1、列举 JavaScript 中所有假值 2、请写出一个函数initArray，接受两个参数 m 和 n，返回一个数组，它的长度是 m，每个值都是 n 3、请写出一个函数yesterday，接受一个 Date 类型参数 date，返回一个 Date，正好是 date 的前一天 4、现有二个字段：id，Number 类型； name，String 类型。取值自定义，请写出相应的 json。 5、完成extname函数，它会接受一个文件名作为参数，你需要返回它的扩展名。例如，输入emoji.png，返回.png 6、请写出以下代码的执行结果 var name = ‘World!’; (() =&gt; { if (typeof name === ‘undefined’) { var name = ‘Jack’; console.log(‘Goodbye ‘ + name); } else { console.log(‘Hello ‘ + name); } })(); 1、列举 HTML 中标签常用的全局属性，并描述其作用 2、列举 HTML 中常用的块级元素，并描述其作用 3、列举 HTML 中常用的行内元素，并描述其作用 4、列举 HTML5 中 input 标签的新增 type 属性值，并描述其作用 5、列举 form 标签的 method 属性和 enctype 属性值，并描述其作用 6、列举 button 标签的 type 属性值，并描述其作用 7、定义一个 a 标签，在浏览器新窗口中打开http://www.baidu.com 8、列举常用 HTTP 状态码及其含义 CSS 1、 有一个div#wrapper元素，高、宽度都未知。它其中有一个宽高都为 100px 的div#box元素，请你完成 CSS，使得div#box在div#wrapper内水平、垂直方向居中。 2、韩梅梅拒绝了李雷，李雷伤心地问韩梅梅，你到底喜欢怎么样的男生。韩梅梅说，她喜欢又高、又富、又帅的男生。假设现在页面上有很多个 div 元素代表不同的男生，类名表示他们具有的特性，例如 tall 表示高，wealthy 表示富，handsome 表示帅。请你完成 CSS， 给韩梅梅喜欢的男生加上红色的边框（ 1px solid red ）。 三卷 react 面试题汇总  React 中 keys 的作用是什么？ Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。 render () { return (  &lt;ul&gt;  {this.state.todoItems.map(({item, key}) =&gt; {  return &lt;li key={key}&gt;{item}&lt;/li&gt;  })}  &lt;/ul&gt; ) } 在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。在 React Diff 算法中 React 会借助元素的 Key 值来判断该元素是新近创建的还是被移动而来的元素，从而减少不必要的元素重渲染。此外，React 还需要借助 Key 值来判断元素与本地状态的关联关系，因此我们绝不可忽视转换函数中 Key 的重要性。  调用 setState 之后发生了什么？ 在代码中调用 setState 函数之后，React 会将传入的参数对象与组件当前的状态合并，然后触发所谓的调和过程（Reconciliation）。经过调和过程，React 会以相对高效的方式根据新的状态构建 React 元素树并且着手重新渲染整个 UI 界面。在 React 得到元素树之后，React 会自动计算出新的树与老树的节点差异，然后根据差异对界面进行最小化重渲染。在差异计算算法中，React 能够相对精确地知道哪些位置发生了改变以及应该如何改变，这就保证了按需更新，而不是全部重新渲染。  react 生命周期函数 初始化阶段： getDefaultProps:获取实例的默认属性 getInitialState:获取每个实例的初始化状态 componentWillMount：组件即将被装载、渲染到页面上 render:组件在这里生成虚拟的 DOM 节点 componentDidMount:组件真正在被装载之后 运行中状态： componentWillReceiveProps:组件将要接收到属性的时候调用 shouldComponentUpdate:组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止 render 调用，后面的函数不会被继续执行了） componentWillUpdate:组件即将更新不能修改属性和状态 render:组件重新描绘 componentDidUpdate:组件已经更新 销毁阶段： componentWillUnmount:组件即将销毁 shouldComponentUpdate 是做什么的，（react 性能优化是哪个周期函数？） shouldComponentUpdate 这个方法用来判断是否需要调用 render 方法重新描绘 dom。因为 dom 的描绘非常消耗性能，如果我们能在 shouldComponentUpdate 方法中能够写出更优化的 dom diff 算法，可以极大的提高性能。  参考 react 性能优化-sf 为什么虚拟 dom 会提高性能?(必考) 虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能。 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异把 2 所记录的差异应用到步骤 1 所构建的真正的 DOM 树上，视图就更新了。  参考 如何理解虚拟 DOM?-zhihu react diff 原理（常考，大厂必考） 把树形结构按照层级分解，只比较同级元素。 给列表结构的每个单元添加唯一的 key 属性，方便比较。 React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字） 合并操作，调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 选择性子树渲染。开发人员可以重写 shouldComponentUpdate 提高 diff 的性能。 参考：React 的 diff 算法  React 中 refs 的作用是什么？ Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回： class CustomForm extends Component { handleSubmit = () =&gt; {  console.log('Input Value: ', this.input.value) } render() {  return (  &lt;form onSubmit={this.handleSubmit}&gt;  &lt;input type=text ref={input =&gt; (this.input = input)} /&gt;  &lt;button type=submit&gt;Submit&lt;/button&gt;  &lt;/form&gt;  ) } } 上述代码中的 input 域包含了一个 ref 属性，该属性声明的回调函数会接收 input 对应的 DOM 元素，我们将其绑定到 this 指针以便在其他的类函数中使用。另外值得一提的是，refs 并不是类组件的专属，函数式组件同样能够利用闭包暂存其值： function CustomForm({ handleSubmit }) { let inputElement return (  &lt;form onSubmit={() =&gt; handleSubmit(inputElement.value)}&gt;  &lt;input type=text ref={input =&gt; (inputElement = input)} /&gt;  &lt;button type=submit&gt;Submit&lt;/button&gt;  &lt;/form&gt; ) } 如果你创建了类似于下面的 Twitter 元素，那么它相关的类定义是啥样子的？ &lt;Twitter username=tylermcginnis33&gt; {user =&gt; (user === null ? &lt;Loading /&gt; : &lt;Badge info={user} /&gt;)} &lt;/Twitter&gt; import React, { Component, PropTypes } from 'react' import fetchUser from 'twitter' // fetchUser take in a username returns a promise // which will resolve with that username's data. class Twitter extends Component { // finish this } 如果你还不熟悉回调渲染模式（Render Callback Pattern），这个代码可能看起来有点怪。这种模式中，组件会接收某个函数作为其子组件，然后在渲染函数中以 props.children 进行调用： import React, { Component, PropTypes } from 'react' import fetchUser from 'twitter' class Twitter extends Component { state = {  user: null } static propTypes = {  username: PropTypes.string.isRequired } componentDidMount() {  fetchUser(this.props.username).then(user =&gt; this.setState({ user })) } render() {  return this.props.children(this.state.user) } } 这种模式的优势在于将父组件与子组件解耦和，父组件可以直接访问子组件的内部状态而不需要再通过 Props 传递，这样父组件能够更为方便地控制子组件展示的 UI 界面。譬如产品经理让我们将原本展示的 Badge 替换为 Profile，我们可以轻易地修改下回调函数即可： &lt;Twitter username=tylermcginnis33&gt; {user =&gt; (user === null ? &lt;Loading /&gt; : &lt;Profile info={user} /&gt;)} &lt;/Twitter&gt; 展示组件(Presentational component)和容器组件(Container component)之间有何不同 展示组件关心组件看起来是什么。展示专门通过 props 接受数据和回调，并且几乎不会有自身的状态，但当展示组件拥有自身的状态时，通常也只关心 UI 状态而不是数据的状态。 容器组件则更关心组件是如何运作的。容器组件会为展示组件或者其它容器组件提供数据和行为(behavior)，它们会调用 Flux actions，并将其作为回调提供给展示组件。容器组件经常是有状态的，因为它们是(其它组件的)数据源。 类组件(Class component)和函数式组件(Functional component)之间有何不同 类组件不仅允许你使用更多额外的功能，如组件自身的状态和生命周期钩子，也能使组件直接访问 store 并维持状态 当组件仅是接收 props，并将组件自身渲染到页面时，该组件就是一个 ‘无状态组件(stateless component)’，可以使用一个纯函数来创建这样的组件。这种组件也被称为哑组件(dumb components)或展示组件 (组件的)状态(state)和属性(props)之间有何不同 State 是一种数据结构，用于组件挂载时所需数据的默认值。State 可能会随着时间的推移而发生突变，但多数时候是作为用户事件行为的结果。 Props(properties 的简写)则是组件的配置。props 由父组件传递给子组件，并且就子组件而言，props 是不可变的(immutable)。组件不能改变自身的 props，但是可以把其子组件的 props 放在一起(统一管理)。Props 也不仅仅是数据–回调函数也可以通过 props 传递。  何为受控组件(controlled component) 在 HTML 中，类似 &lt;input&gt;, &lt;textarea&gt; 和 &lt;select&gt; 这样的表单元素会维护自身的状态，并基于用户的输入来更新。当用户提交表单时，前面提到的元素的值将随表单一起被发送。但在 React 中会有些不同，包含表单元素的组件将会在 state 中追踪输入的值，并且每次调用回调函数时，如 onChange 会更新 state，重新渲染组件。一个输入表单元素，它的值通过 React 的这种方式来控制，这样的元素就被称为”受控元素”。  何为高阶组件(higher order component) 高阶组件是一个以组件为参数并返回一个新组件的函数。HOC 运行你重用代码、逻辑和引导抽象。最常见的可能是 Redux 的 connect 函数。除了简单分享工具库和简单的组合，HOC 最好的方式是共享 React 组件之间的行为。如果你发现你在不同的地方写了大量代码来做同一件事时，就应该考虑将代码重构为可重用的 HOC。  为什么建议传递给 setState 的参数是一个 callback 而不是一个对象 因为 this.props 和 this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state。  除了在构造函数中绑定 this，还有其它方式吗 你可以使用属性初始值设定项(property initializers)来正确绑定回调，create-react-app 也是默认支持的。在回调中你可以使用箭头函数，但问题是每次组件渲染时都会创建一个新的回调。  (在构造函数中)调用 super(props) 的目的是什么 在 super() 被调用之前，子类是不能使用 this 的，在 ES2015 中，子类必须在 constructor 中调用 super()。传递 props 给 super() 的原因则是便于(在子类中)能在 constructor 访问 this.props。  应该在 React 组件的何处发起 Ajax 请求 在 React 组件中，应该在 componentDidMount 中发起网络请求。这个方法会在组件第一次“挂载”(被添加到 DOM)时执行，在组件的生命周期中仅会执行一次。更重要的是，你不能保证在组件挂载之前 Ajax 请求已经完成，如果是这样，也就意味着你将尝试在一个未挂载的组件上调用 setState，这将不起作用。在 componentDidMount 中发起网络请求将保证这有一个组件可以更新了。  描述事件在 React 中的处理方式。 为了解决跨浏览器兼容性问题，您的 React 中的事件处理程序将传递 SyntheticEvent 的实例，它是 React 的浏览器本机事件的跨浏览器包装器。 这些 SyntheticEvent 与您习惯的原生事件具有相同的接口，除了它们在所有浏览器中都兼容。有趣的是，React 实际上并没有将事件附加到子节点本身。React 将使用单个事件监听器监听顶层的所有事件。这对于性能是有好处的，这也意味着在更新 DOM 时，React 不需要担心跟踪事件监听器。  createElement 和 cloneElement 有什么区别？ React.createElement():JSX 语法就是用 React.createElement()来构建 React 元素的。它接受三个参数，第一个参数可以是一个标签名。如 div、span，或者 React 组件。第二个参数为传入的属性。第三个以及之后的参数，皆作为组件的子组件。 React.createElement(type, [props], [...children]) React.cloneElement()与 React.createElement()相似，不同的是它传入的第一个参数是一个 React 元素，而不是标签名或组件。新添加的属性会并入原有的属性，传入到返回的新元素中，而就的子元素奖杯替换。 React.cloneElement(element, [props], [...children]) React 中有三种构建组件的方式 React.createClass()、ES6 class 和无状态函数。  react 组件的划分业务组件技术组件？ 根据组件的职责通常把组件分为 UI 组件和容器组件。 UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。 两者通过 React-Redux 提供 connect 方法联系起来。  简述 flux 思想 Flux 的最大特点，就是数据的”单向流动”。 用户访问 View View 发出用户的 Action Dispatcher 收到 Action，要求 Store 进行相应的更新 Store 更新后，发出一个”change”事件 View 收到”change”事件后，更新页面 React 项目用过什么脚手架（本题是开放性题目） creat-react-app Yeoman 等  了解 redux 么，说一下 redux redux 是一个应用数据流框架，主要是解决了组件间状态共享的问题，原理是集中式管理，主要有三个核心方法，action，store，reducer，工作流程是 view 调用 store 的 dispatch 接收 action 传入 store，reducer 进行 state 操作，view 通过 store 提供的 getState 获取最新的数据，flux 也是用来进行数据操作的，有四个组成部分 action，dispatch，view，store，工作流程是 view 发出一个 action，派发器接收 action，让 store 进行数据更新，更新完成以后 store 发出 change，view 接受 change 更新视图。Redux 和 Flux 很像。主要区别在于 Flux 有多个可以改变应用状态的 store，在 Flux 中 dispatcher 被用来传递数据到注册的回调事件，但是在 redux 中只能定义一个可更新状态的 store，redux 把 store 和 Dispatcher 合并,结构更加简单清晰 新增 state,对状态的管理更加明确，通过 redux，流程更加规范了，减少手动编码量，提高了编码效率，同时缺点时当数据更新时有时候组件不需要，但是也要重新绘制，有些影响效率。一般情况下，我们在构建多交互，多数据流的复杂项目应用时才会使用它们  redux 有什么缺点 一个组件所需要的数据，必须由父组件传过来，而不能像 flux 中直接从 store 取。 当一个组件相关数据更新时，即使父组件不需要用到这个组件，父组件还是会重新 render，可能会有效率影响，或者需要写复杂的 shouldComponentUpdate 进行判断。 es6 面试题汇总  聊聊 promise promise 是一个异步函数，主要是为了解决异步处理回调地狱(也就是循环嵌套的问题)而产生的，有 3 种状态，Fulfilled 为成功的状态， Rejected 为失败的状态，Pending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态，要会写 promise 这个方法。  ES6 特性你了解多少？如果遇到一个东西不知道是 ES6 还是 ES5，你改如何区分？ 常用的 es6 新特性：let &amp;&amp; const；let 命令也用于声明对象，但是作用域为局部；iterable 类型。为了统一集合类型，ES6 标准引入了新的 iterable 类型，Array、Map 和 Set 都属于 iterable 类型，具有 iterable 类型的集合可以通过新的 for … of 循环来遍历。es6 比 es5 增加了很多特殊的方法，如果你遇到了这些特殊的方法， 你就可以确定它是 es6。如果你的代码中没有引用这些特殊的方法，那我们就可以认为他是 es5 的。所以前提你需要了解 es6 的语法才能做判断，高频使用的特性有箭头函数、解构赋值、let、const。  ES6 的继承和 ES5 的继承有什么区别 es5 的继承是通过原型或者是构造函数机制来实现，es6 用过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现，子类必须在 constructor 方法中调用 super 方法。  let 和 const 的优点？ let 和 const 有了块级作用域，相比于 var 变量声明不会提升。  ES6 generator 是什么，async / await 实现原理？ generator 函数就是一个封装的异步任务，也就是异步任务的容器，执行 Generator 函数会返回一个遍历器对象,async 函数的实现， 就是将 Generator 函数和自动执行器，包装在一个函数里。 ",
      "url"      : "http://localhost:4000/question/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "IT小屋",
      "category" : "",
      "content": " 技术宅   T型男人  开源工具（可惜不是自己的）  HTTP 协议详解  Redux 实现原理解析及应用  React Hooks 的理解  React Hooks 你真的用对了吗？  日常 API  VsCode 快捷键  业余兴趣   技术宅 T型男人 webpack学习 http://webpack.wuhaolin.cn/ 开源工具（可惜不是自己的） flex调试工具 http://works.kexiaolong.top/flexible-box-display/ HTTP 协议详解 https://blog.csdn.net/weixin_38087538/article/details/82838762 Redux 实现原理解析及应用 https://www.jianshu.com/p/e984206553c2 React Hooks 的理解 https://www.jianshu.com/p/76901410645a React Hooks 你真的用对了吗？ https://zhuanlan.zhihu.com/p/85969406 日常 API  接口示例：百度，腾讯，高德地图JS API示例 在线工具网页：经纬度查询| 批量查询经纬度 |IP归属地 |手机号归属地查询 | 区划代码查询http://www.gpsspg.com/ VsCode 快捷键 https://www.cnblogs.com/informatics/p/8315339.html 业余兴趣  美文网 - 常阅读，多交友！ http://www.mw8.com/ js 秘密花园 http://bonsaiden.github.io/JavaScript-Garden/zh/ IT 技术论坛！ http://community.itbbs.cn/ V2EX 技术论坛 https://www.v2ex.com/ 图片压缩！ https://tinypng.com/ 制作 Icon http://www.bitbug.net/ 视频下载 https://www.haobang.fun/ ",
      "url"      : "http://localhost:4000/reference/",
      "keywords" : ""
    } ,
  
    {
      "title"    : "谁还没点小故事！",
      "category" : "",
      "content": " 暂无 暂无 ",
      "url"      : "http://localhost:4000/self_introduction/",
      "keywords" : ""
    } 
  
]

